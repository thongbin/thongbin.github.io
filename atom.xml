<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[tanghongbin]]></title>
  <subtitle><![CDATA[iOS Developer, S.H.S.F.]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://tanghongbin.me/"/>
  <updated>2018-04-20T08:18:12.131Z</updated>
  <id>http://tanghongbin.me/</id>
  
  <author>
    <name><![CDATA[tanghongbin]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[从runtime源码角度看isa指向]]></title>
    <link href="http://tanghongbin.me/2018/04/16/ISA/"/>
    <id>http://tanghongbin.me/2018/04/16/ISA/</id>
    <published>2018-04-16T11:28:31.000Z</published>
    <updated>2018-04-20T08:18:12.131Z</updated>
    <content type="html"><![CDATA[<p>isa是什么？官方解释是：</p>
<blockquote>
<p>Every object has an isa instance variable that identifies the object’s class. The runtime uses this pointer to determine the actual class of the object when it needs to.</p>
</blockquote>
<p>不过我不打算在这里从零开始叙述 <code>isa</code> 是什么，能干什么，在这里，我假设大家是已经理解 <code>isa</code> 是什么了。<br><a id="more"></a></p>
<p>这篇文章是从 <code>runtime</code> 源码的角度出发，来探索下 <code>isa</code> 的指向问题。先来看一段代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"SuperClass.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"SonClass.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// insert code here...</span></span><br><span class="line">        <span class="built_in">BOOL</span> foo1 = [[SuperClass <span class="keyword">class</span>] isKindOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]];</span><br><span class="line">        <span class="built_in">BOOL</span> foo2 = [[SuperClass new] isKindOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"foo1 is 1, actually foo1 is %d"</span>,foo1);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"foo2 is 1, actually foo2 is %d"</span>,foo2);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">BOOL</span> foo3 = [[SuperClass <span class="keyword">class</span>] isMemberOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]];</span><br><span class="line">        <span class="built_in">BOOL</span> foo4 = [[SuperClass new] isMemberOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"foo3 is 0, actually foo3 is %d"</span>,foo3);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"foo4 is 0, actually foo4 is %d"</span>,foo4);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">BOOL</span> foo5 = [[SuperClass <span class="keyword">class</span>] isMemberOfClass:[SuperClass <span class="keyword">class</span>]];</span><br><span class="line">        <span class="built_in">BOOL</span> foo6 = [[SuperClass new] isMemberOfClass:[SuperClass <span class="keyword">class</span>]];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"foo5 is 0, actually foo5 is %d"</span>,foo5);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"foo6 is 1, actually foo6 is %d"</span>,foo6);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">BOOL</span> foo7 = [[SonClass <span class="keyword">class</span>] isKindOfClass:[SuperClass <span class="keyword">class</span>]];</span><br><span class="line">        <span class="built_in">BOOL</span> foo8 = [[SonClass new] isKindOfClass:[SuperClass <span class="keyword">class</span>]];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"foo7 is 0, actually foo7 is %d"</span>,foo7);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"foo8 is 1, actually foo8 is %d"</span>,foo8);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>SuperClass</code> 是继承自<code>NSObject</code>类的，而<code>SonClass</code>的父类是 <code>SuperClass</code>，上面这段看似简单的代码打印出来的是：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">foo1 is <span class="number">1</span>, actually foo1 is <span class="number">1</span></span><br><span class="line">foo2 is <span class="number">1</span>, actually foo2 is <span class="number">1</span></span><br><span class="line">foo3 is <span class="number">0</span>, actually foo3 is <span class="number">0</span></span><br><span class="line">foo4 is <span class="number">0</span>, actually foo4 is <span class="number">0</span></span><br><span class="line">foo5 is <span class="number">0</span>, actually foo5 is <span class="number">0</span></span><br><span class="line">foo6 is <span class="number">1</span>, actually foo6 is <span class="number">1</span></span><br><span class="line">foo7 is <span class="number">0</span>, actually foo7 is <span class="number">0</span></span><br><span class="line">foo8 is <span class="number">1</span>, actually foo8 is <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>不难看出，这里要讨论的的四个方法分别是：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)isKindOfClass:(Class)aClass;</span><br><span class="line">- (<span class="built_in">BOOL</span>)isMemberOfClass:(Class)aClass;</span><br><span class="line">+ (<span class="built_in">BOOL</span>)isKindOfClass:(Class)aClass;</span><br><span class="line">+ (<span class="built_in">BOOL</span>)isMemberOfClass:(Class)aClass;</span><br></pre></td></tr></table></figure></p>
<p>讨论方法的最直接方式，看源码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">return</span> object_getClass((<span class="keyword">id</span>)<span class="keyword">self</span>) == cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> <span class="keyword">class</span>] == cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class tcls = object_getClass((<span class="keyword">id</span>)<span class="keyword">self</span>); tcls; tcls = tcls-&gt;superclass) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tcls == cls) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class tcls = [<span class="keyword">self</span> <span class="keyword">class</span>]; tcls; tcls = tcls-&gt;superclass) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tcls == cls) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看看源码，发现实例方法与类方法之间的主要区别是，<code>[self class]</code> 与 <code>object_getClass((id)self)</code> ，再继续来看代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (Class)<span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> object_getClass(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Class object_getClass(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj) <span class="keyword">return</span> obj-&gt;getIsa();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> Nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以，其实逻辑是一样的，无论是实例方法还是类方法，最后都是要去获取 <code>isa</code> ，从这里也可以看得出，类其实也是一个对象，「毕竟在面向对象的世界里，万物皆对象」。</p>
<p>好了，既然在这一步取得了 <code>isa</code> ，就来看具体的方法实现了，其实看了源码，很简单， <code>isMemberOfClass</code> 的逻辑就是直接用取得的 <code>isa</code> 与 <code>cls</code> 做比较，得出结果然后返回。</p>
<p>而在 <code>isKindOfClass</code> 里面则是多了一层 <code>for-loop</code> 的逻辑，简单分析一下， <code>loop</code> 的初始值 <code>tcls</code> 是当前对象的 <code>isa class</code> ，循环条件是 <code>tcls</code> 不为空，最后是下一次循环的取值，是 <code>tcls-&gt;superclass</code> ，就是 <code>tcls</code> 的父类，循环体是判断是否相等的逻辑，最后是返回结果。</p>
<p>熟悉 <code>runtime</code> 里的 <code>isa、meta class</code> 概念的都知道，类的 <code>isa</code> 是指向其元类 <code>metaclass</code> 的，实例的 <code>isa</code> 是指向类 <code>class</code> 的， <code>NSObject（Root class）</code> 的 <code>isa</code> 是指向 <code>meta root clas</code> ，而 <code>meta root class</code> 的父类是 <code>NSObject</code> ，这样就形成一个闭环，（ <code>NSObject</code> 的 父类 是 <code>nil</code> <code>，meta root Class</code> 的 父类是 <code>nil</code> ），看不懂描述的时候，直接看图：</p>
<div align="center"><br><img src="/images/post_images/isa.png" alt="GitHub" title="ISA" width="600" height="550"><br></div>


<p>然后结合上图回过头来看一开始的代码，<code>SuperClass</code> 的 <code>isa</code> 是指向它的元类 <code>meta class</code> ，并不等于 <code>NSObject</code> ，然后 <code>tcls = tcls-&gt;superclass</code>，<br><code>tcls = meta Root class</code> ，也不等于 <code>NSObject</code> ，然后， <code>tcls = meta Root class-&gt;superclass</code> ，也就是 <code>tcls = NSObject</code> ，所以最后结果是 <code>true</code> ，也就是 <code>1</code> 了。</p>
<p>结合示例图，就能理解一开始的代码的输出结果了。</p>
<p>文章里只是从另一个角度去验证下 <code>isa</code> 的指向原理，闭环方式，说的只是 <code>isa</code> 里很基础概念，理解就好了，重要的是应用，其中， <code>isa</code> 比较重要的应用是：<code>KVO</code> 的实现原理，下篇会研究下。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>isa是什么？官方解释是：</p>
<blockquote>
<p>Every object has an isa instance variable that identifies the object’s class. The runtime uses this pointer to determine the actual class of the object when it needs to.</p>
</blockquote>
<p>不过我不打算在这里从零开始叙述 <code>isa</code> 是什么，能干什么，在这里，我假设大家是已经理解 <code>isa</code> 是什么了。<br>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://tanghongbin.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[NSOperation 与 GCD 的对比]]></title>
    <link href="http://tanghongbin.me/2018/03/26/nsoperationvsgcd/"/>
    <id>http://tanghongbin.me/2018/03/26/nsoperationvsgcd/</id>
    <published>2018-03-26T09:04:09.000Z</published>
    <updated>2018-03-26T09:37:44.244Z</updated>
    <content type="html"><![CDATA[<p>说在前面，无论是选择 <code>GCD</code> 还是 <code>NSOperation</code> ，从来都不应该用好与坏去区分，只能说要看具体的业务需求，考虑实际使用情况。</p>
<a id="more"></a>
<p>对比它们可以从下面几个角度来说：</p>
<ul>
<li><p>从实现层面上看，<code>NSOperationQueue</code> 是基于 <code>GCD</code> 的更高层的封装，早起并不是，从 OS X 10.10 开始可以通过设置 <code>underlyingQueue</code> 来把 <code>operation</code> 放到已有的 <code>dispatch queue</code> 中。</p>
</li>
<li><p>从易用性角度，<code>GCD</code> 由于采用 <code>C</code> 风格的 <code>API</code>，在调用上比使用面向对象风格的 <code>NSOperation</code> 要简单一些，<code>NSOperation</code> 则以对象形式去控制任务的执行与并发，构建出来的业务流程能更方便于开发者理解。</p>
</li>
<li><p>从对任务的控制性来说，<code>NSOperation</code> 显著得好于 <code>GCD</code>，和 <code>GCD</code> 相比支持了 <code>Cancel</code> 操作（注：在 iOS8 中 GCD 引入了 <code>dispatch_block_cancel</code> 和 <code>dispatch_block_testcancel，也可以支持</code> <code>Cancel</code> 操作了），支持任务之间的依赖关系，支持同一个队列中任务的优先级设置，同时还可以通过 <code>KVO</code> 来监控任务的执行情况。这些通过 <code>GCD</code> 也可以实现，不过需要很多代码，使用 <code>NSOperation</code> 显得方便了很多。</p>
</li>
<li><p>从第三方库的角度，知名的第三方库如 <code>AFNetworking</code> 和 <code>SDWebImage</code> 背后都是使用 <code>NSOperation</code> ，也从另一方面说明对于需要复杂并发控制的需求，<code>NSOperation</code> 是更好的选择（当然也不是绝对的，例如知名的 <a href="https://github.com/ParsePlatform/Parse-SDK-iOS-OSX" target="_blank" rel="noopener">Parse SDK</a> 就完全没有使用 NSOperation，全部使用 GCD，其中涉及到大量的 GCD 高级用法，这里有<a href="https://github.com/ChenYilong/ParseSourceCodeStudy" target="_blank" rel="noopener">相关解析</a>）。</p>
</li>
</ul>
<h5 id="参考资料">参考资料</h5><ul>
<li><a href="http://www.raywenderlich.com/19788/how-to-use-nsoperations-and-nsoperationqueues" target="_blank" rel="noopener">http://www.raywenderlich.com/19788/how-to-use-nsoperations-and-nsoperationqueues</a></li>
<li><a href="http://www.humancode.us/2014/08/14/target-queues.html" target="_blank" rel="noopener">http://www.humancode.us/2014/08/14/target-queues.html</a></li>
<li><a href="http://www.dribin.org/dave/blog/archives/2009/05/05/concurrent_operations/" target="_blank" rel="noopener">http://www.dribin.org/dave/blog/archives/2009/05/05/concurrent_operations/</a></li>
<li><a href="http://www.jianshu.com/p/0b0d9b1f1f19" target="_blank" rel="noopener">http://www.jianshu.com/p/0b0d9b1f1f19</a></li>
<li><a href="http://www.cnblogs.com/tangbinblog/p/4133481.html" target="_blank" rel="noopener">http://www.cnblogs.com/tangbinblog/p/4133481.html</a></li>
<li><a href="http://www.saitjr.com/ios/ios-" target="_blank" rel="noopener">http://www.saitjr.com/ios/ios-gcd-deadlock.html</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>说在前面，无论是选择 <code>GCD</code> 还是 <code>NSOperation</code> ，从来都不应该用好与坏去区分，只能说要看具体的业务需求，考虑实际使用情况。</p>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://tanghongbin.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[NSOperation & NSOPerationQueue]]></title>
    <link href="http://tanghongbin.me/2018/03/23/NSOperation/"/>
    <id>http://tanghongbin.me/2018/03/23/NSOperation/</id>
    <published>2018-03-23T09:25:41.000Z</published>
    <updated>2018-04-08T14:14:07.361Z</updated>
    <content type="html"><![CDATA[<h1 id="NSOperation">NSOperation</h1><p>使用 <code>GCD</code> 很方便多线程执行并发任务，但是也有缺点，如果想实现线程之间的依赖，使用 <code>GCD</code> 就需要嵌套，嵌套就容易出现死锁的问题。</p>
<a id="more"></a>
<p>关于这个问题，苹果提供了一套另一套多线程实现标准 <code>NSOperation</code><br><code>NSOperation</code> 是基于 <code>GCD</code> 的更高层的封装，只是使用起来方不方便是见仁见智的事，重要的是 <code>NSOperation</code> 提供了操作依赖的接口 <code>addDependency</code> 。</p>
<h2 id="NSOperation_使用:">NSOperation 使用:</h2><p><code>NSOperation</code> 是一个抽象类，不能直接使用，使用的时候要先继承子类，实现相关方法，或者使用系统定义好的子类 <code>NSInvocationOperation</code> 和 <code>NSBlockOperation</code> 。</p>
<h4 id="NSInvokcationOperation"><code>NSInvokcationOperation</code></h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">NSInvocationOperation</span> *operation = [[<span class="built_in">NSInvocationOperation</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run:) object:<span class="literal">nil</span>];</span><br><span class="line">[operation start];</span><br></pre></td></tr></table></figure>
<ul>
<li><p>第1行初始化了一个<code>NSInvocationOperation</code>对象，它是基于一个对象和<code>selector</code>来创建操作</p>
</li>
<li><p>第2行调用了<code>start</code>方法，紧接着会马上执行封装好的操作，也就是会调用<code>self</code>的<code>run:</code>，可以利用<code>obejct</code>携带参数</p>
</li>
<li><p>默认情况下，调用了start方法后并不会开一条新线程去执行操作，而是在当前线程同步执行操作。</p>
</li>
</ul>
<h4 id="NSBlockOperation"><code>NSBlockOperation</code></h4><ul>
<li>同样的，这里时与当前线程同步执行一个任务</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">NSBlockOperation</span> *operation = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^()&#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"执行了一个新的操作"</span>);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">// 开始执行任务</span></span><br><span class="line">[operation start];</span><br></pre></td></tr></table></figure>
<ul>
<li>并发执行多个任务的方式:</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSBlockOperation</span> *operation = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^()&#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"执行第1次操作，线程：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[operation addExecutionBlock:^() &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"又执行了1个新的操作，线程：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[operation addExecutionBlock:^() &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"又执行了1个新的操作，线程：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[operation addExecutionBlock:^() &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"又执行了1个新的操作，线程：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始执行任务</span></span><br><span class="line">[operation start];</span><br></pre></td></tr></table></figure>
<ul>
<li>单独使用 <code>NSOperation</code> 及其子类时，任务会默认在当前线程执行。以上是 <code>NSOperation</code> 的基本使用方法。</li>
</ul>
<h1 id="NSOperationQueue">NSOperationQueue</h1><p>前面单独使用 <code>NSOperation</code> 的 <code>start</code> ，默认是在当前线程同步执行的。当把 <code>operation</code> 放进 <code>operationqueue</code> <code>的时候，operationqueue</code> 会自动并发执行 <code>queue</code> 里面的 <code>operations</code> <code>，NSOperationQueue</code> 有属性 <code>maxConcurrentCount</code> 可以控制并发数，当值为 <code>1</code> 时，是串行队列，按 <code>FIFO</code> 顺序执行 <code>operation</code>。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSBlockOperation</span> *block1 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"%@  1"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line">block1.name = <span class="string">@"1"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSBlockOperation</span> *block2 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"%@  2"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line">block2.name = <span class="string">@"2"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSBlockOperation</span> *block3 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@  3"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line">block3.name = <span class="string">@"3"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSBlockOperation</span> *block4 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"%@  4"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line">block4.name = <span class="string">@"4"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSOperationQueue</span> *queue = [<span class="built_in">NSOperationQueue</span> mainQueue];</span><br><span class="line">queue.maxConcurrentOperationCount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">[queue addOperation:block1];</span><br><span class="line">[queue addOperation:block2];</span><br><span class="line">[queue addOperation:block3];</span><br><span class="line">[queue addOperation:block4];</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">//number 的不同代表不是同一条线程</span></span><br><span class="line">&lt;<span class="built_in">NSThread</span>: <span class="number">0x6000000721c0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;  <span class="number">1</span></span><br><span class="line">&lt;<span class="built_in">NSThread</span>: <span class="number">0x6000000721c0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;  <span class="number">2</span></span><br><span class="line">&lt;<span class="built_in">NSThread</span>: <span class="number">0x6000000721c0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;  <span class="number">3</span></span><br><span class="line">&lt;<span class="built_in">NSThread</span>: <span class="number">0x6000000721c0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;  <span class="number">4</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>maxConcurrentCount</code> 为 <code>1</code> <code>时，queue</code> 本身是串行队列时，例如 <code>[NSOpertionQueue mainQueue]</code> , <code>operation</code> 都会在同一条线程上按加入队列的顺序执行，如果 <code>queue</code> 是新建的 <code>[NSOperationQueue new]</code>，<code>operation</code> 不一定都在同一条线程上执行。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">//number 的不同代表不是同一条线程</span></span><br><span class="line">&lt;<span class="built_in">NSThread</span>: <span class="number">0x600000066300</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;  <span class="number">1</span></span><br><span class="line">&lt;<span class="built_in">NSThread</span>: <span class="number">0x600000066300</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;  <span class="number">2</span></span><br><span class="line">&lt;<span class="built_in">NSThread</span>: <span class="number">0x600000066300</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;  <span class="number">3</span></span><br><span class="line">&lt;<span class="built_in">NSThread</span>: <span class="number">0x600000066300</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;  <span class="number">4</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="NSOperation">NSOperation</h1><p>使用 <code>GCD</code> 很方便多线程执行并发任务，但是也有缺点，如果想实现线程之间的依赖，使用 <code>GCD</code> 就需要嵌套，嵌套就容易出现死锁的问题。</p>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://tanghongbin.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Git 全局忽略 不需要的版本跟踪的文件]]></title>
    <link href="http://tanghongbin.me/2015/10/19/gitignorefile/"/>
    <id>http://tanghongbin.me/2015/10/19/gitignorefile/</id>
    <published>2015-10-19T04:25:24.000Z</published>
    <updated>2018-03-23T02:33:50.562Z</updated>
    <content type="html"><![CDATA[<h5 id="摘录_让_GIT_全局性的忽略_-DS_STORE">摘录 <a href="http://mednoter.com/gitignore-global.html" target="_blank" rel="noopener">让 GIT 全局性的忽略 .DS_STORE</a></h5><p>在Mac 的文件夹下，系统会生成.DS_Store文件，具体什么作用暂时不需要关心，若果在同时又是Git仓库的文件夹下，强烈建议忽略此文件</p>
<p>Mac 中每个目录都会有个文件叫.DS_Store, 用于存储当前文件夹的一些 Meta 信息。每次提交代码时，我都要在代码仓库的 .gitignore 中声明，忽略这类文件。有方法可以全局性的忽略某种类型的文件吗？</p>
<a id="more"></a>
<p>按照以下两步就可实现</p>
<p>创建 <code>~/.gitignore_global</code> 文件，把需要全局忽略的文件类型塞到这个文件里。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># .gitignore_global</span><br><span class="line">####################################</span><br><span class="line">######## OS generated files ########</span><br><span class="line">####################################</span><br><span class="line">.DS_Store</span><br><span class="line">.DS_Store?</span><br><span class="line">*.swp</span><br><span class="line">._*</span><br><span class="line">.Spotlight-V100</span><br><span class="line">.Trashes</span><br><span class="line">Icon?</span><br><span class="line">ehthumbs.db</span><br><span class="line">Thumbs.db</span><br><span class="line">####################################</span><br><span class="line">############# Packages #############</span><br><span class="line">####################################</span><br><span class="line">*.7z</span><br><span class="line">*.dmg</span><br><span class="line">*.gz</span><br><span class="line">*.iso</span><br><span class="line">*.jar</span><br><span class="line">*.rar</span><br><span class="line">*.tar</span><br><span class="line">*.zip</span><br></pre></td></tr></table></figure></p>
<p>2.在 ~/.gitconfig 中引入 .gitignore_global。<br>这是我的.gitconfig 文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[user]</span><br><span class="line">    name = xiaoronglv</span><br><span class="line">    email = xxxxx@gmail.com</span><br><span class="line">[push]</span><br><span class="line">    default = matching</span><br><span class="line">[core]</span><br><span class="line">    excludesfile = /Users/xiaoronglv/.gitignore_global</span><br></pre></td></tr></table></figure></p>
<p>在所有的文件夹下 <code>.DS_Store</code> <code>.swp</code> <code>.zip</code> 等文件类型会被 <code>Git</code> 自动忽略。</p>
<p>demo</p>
<p>参考资料</p>
<p><a href="https://help.github.com/articles/ignoring-files/" target="_blank" rel="noopener">Github: Create a global .gitignore</a><br><a href="http://osxdaily.com/2009/12/31/what-is-a-ds_store-file/" target="_blank" rel="noopener">What is .DS_Store file?</a><br><a href="http://stackoverflow.com/questions/18393498/gitignore-all-the-ds-store-files-in-every-folder-and-subfolder" target="_blank" rel="noopener">.gitignore all the .DS_Store files in every folder and subfolder</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h5 id="摘录_让_GIT_全局性的忽略_-DS_STORE">摘录 <a href="http://mednoter.com/gitignore-global.html" target="_blank" rel="noopener">让 GIT 全局性的忽略 .DS_STORE</a></h5><p>在Mac 的文件夹下，系统会生成.DS_Store文件，具体什么作用暂时不需要关心，若果在同时又是Git仓库的文件夹下，强烈建议忽略此文件</p>
<p>Mac 中每个目录都会有个文件叫.DS_Store, 用于存储当前文件夹的一些 Meta 信息。每次提交代码时，我都要在代码仓库的 .gitignore 中声明，忽略这类文件。有方法可以全局性的忽略某种类型的文件吗？</p>]]>
    
    </summary>
    
      <category term="Git" scheme="http://tanghongbin.me/categories/Git/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[IBDesignable &  IBInspectable]]></title>
    <link href="http://tanghongbin.me/2015/09/22/IBDesignable-IBInspectable/"/>
    <id>http://tanghongbin.me/2015/09/22/IBDesignable-IBInspectable/</id>
    <published>2015-09-22T03:03:09.000Z</published>
    <updated>2018-03-23T02:33:32.601Z</updated>
    <content type="html"><![CDATA[<p>Xcode6开始，Apple提供给开发者两个很给力的宏（在Objective－C是宏，在Swift里是关键字）</p>
<a id="more"></a>
<p>#@IBDesignable<br>顾名思义，从命名上就能看出这个是跟UI开发有关的，自定义视图的时候，当应用到 UIView 或 NSView 子类中的时候，@ IBDesignable 让 Interface Builder 知道它应该在画布上直接渲染视图。你会看到你的自定义视图在每次更改后不必编译并运行你的应用程序就会显示。</p>
<p>标记一个自定义视图为 IBDesignable，只需在类名前加上 @IBDesignable 的前缀（或是 Objective-C 里的 IB_DESIGNABLE 宏）。你的初始化、布置和绘制方法将被用来在画布上渲染你的自定义视图：</p>
<p>#@IBInspectable</p>
<p>IBInspectable 属性提供了访问旧功能的新方式：用户自定义的运行时属性。从目前的身份检查器（identity inspector）中访问，这些属性在 Interface Builder 被整合到 Xcode 之前就可用了。他们提供了一个强有力的机制来配置一个 NIB，XIB，或者 storyboard 实例中的任何键值编码（key-value coded）属性：</p>
<p>User-Defined Runtime Attributes<br><img src="/images/IBInspectable-runtime-attributes.png" alt="img"></p>
<p>虽然功能强大，运行时属性可能会使工作很繁琐。一个属性的关键字路径，类型和属性值需要在每个实例设置，没有任何自动完成或输入提示，这就需要前往文档或自定义子类的源代码仔细检查设置。 IBInspectable 属性彻底的解决了这个问题：在 Xcode 6，你现在可以指定任何属性作为可检查项并为你的自定义类建立了一个用户界面。</p>
<p>例如，在一个 UIView 子类里，这些属性用它们的值来更新背景层：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Swift</span><br><span class="line">@IBInspectable var cornerRadius: <span class="built_in">CGFloat</span> = <span class="number">0</span> &#123;</span><br><span class="line">   didSet &#123;</span><br><span class="line">       layer.cornerRadius = cornerRadius</span><br><span class="line">       layer.masksToBounds = cornerRadius &gt; <span class="number">0</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">@IBInspectable var borderWidth: <span class="built_in">CGFloat</span> = <span class="number">0</span> &#123;</span><br><span class="line">   didSet &#123;</span><br><span class="line">       layer.borderWidth = borderWidth</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">@IBInspectable var borderColor: <span class="built_in">UIColor</span>? &#123;</span><br><span class="line">   didSet &#123;</span><br><span class="line">       layer.borderColor = borderColor?.CGColor</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>标有 @IBInspectable（或是 Objective-C 中的 IBInspectable），他们就可以很容易在 Interface Builder 的观察面板（inspector panel）里编辑。需要注意的是 Xcode 在这里做了更多的事，属性名称是从 camel- 转换为 title- 模式 并且相关的名称组合在一起：</p>
<p>IBInspectable Attribute Inspector<br><img src="/images/IBInspectable-inspectable.png" alt="img"></p>
<p>因为可检查属性仅仅是用户定义的运行时属性顶部的接口，所以支持相同的类型列表：布尔，字符串和数字（即，NSNumber 或任何数值类型），以及 <code>CGPoint、CGSize、CGRect、UIColor</code> 和 NSRange，额外增加了 UIImage。</p>
<p><code>那些已经熟悉运行时属性的人将注意到在上面的例子中有一些问题。UIColor</code> 是里面唯一支持色彩的类型，而不是原生支持视图 <code>CALayer</code> 的 <code>CGColor.borderColor</code> 会计算 <code>UIColor</code> 属性（通过运行时属性设置）并映射到该层需要的 <code>CGColor。</code></p>
<p>让现有的类型可观察</p>
<p>内置的 <code>Cocoa</code> 类型如果在 <code>Interface Builder</code> 中的属性检查器中没有列出也可以通过扩展来使属性可视。如果你喜欢圆角，你一定会喜欢这个 UIView 扩展：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Swift</span><br><span class="line">extension <span class="built_in">UIView</span> &#123;</span><br><span class="line">    @IBInspectable var cornerRadius: <span class="built_in">CGFloat</span> &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            <span class="keyword">return</span> layer.cornerRadius</span><br><span class="line">        &#125;</span><br><span class="line">        set &#123;</span><br><span class="line">            layer.cornerRadius = newValue</span><br><span class="line">            layer.masksToBounds = newValue &gt; <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>变！你创建的任何 UIView 都将有一个可配置的边界半径。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Xcode6开始，Apple提供给开发者两个很给力的宏（在Objective－C是宏，在Swift里是关键字）</p>]]>
    
    </summary>
    
      <category term="IBDesignable &amp;  IBInspectable&#39;" scheme="http://tanghongbin.me/tags/IBDesignable-IBInspectable/"/>
    
      <category term="iOS" scheme="http://tanghongbin.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[转载]主题更换设计思路]]></title>
    <link href="http://tanghongbin.me/2015/08/20/zhu-ti-geng-huan-she-ji-si-lu/"/>
    <id>http://tanghongbin.me/2015/08/20/zhu-ti-geng-huan-she-ji-si-lu/</id>
    <published>2015-08-20T10:17:41.000Z</published>
    <updated>2018-03-23T02:34:01.792Z</updated>
    <content type="html"><![CDATA[<h4 id="原出处：传人的技术博客">原出处：<a href="http://joeshang.github.io/2014/12/22/theme-change-architecture/" target="_blank" rel="noopener">传人的技术博客</a></h4><p>现在App类似桌面软件的趋势，在功能完善之后，渐渐追求个性化，以满足不同用户的审美，主题更换就是其中一项，像Weico微博客户端，UC浏览器。所谓主题，可以看成相同功能不同展现可视资源的集合，例如，按钮无论在什么主题下都需要背景图片这个资源，只是在不同主题下是不同的背景图片而已。<br><a id="more"></a><br>如何在iOS中实现主题更换的核心思路为：</p>
<p>资源按主题放置：相同功能的资源名称相同，放在不同的主题路径或者前缀使用主题名。<br>增加中间层，隔离不同主题相同功能资源使用的变化。</p>
<h5 id="1-_主题管理">1. 主题管理</h5><p>主题的特性导致代码不关心资源的表现是什么，只关心资源的功能，而主题是易变化的，因此需要将易变化的部分抽离出来，整合到一个管理者中，主题的变化在管理者中完成，而不影响资源使用的地方。而且这个管理者是全局唯一的，因此使用单例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (ThemeManager *)sharedInstance</span><br><span class="line">&#123;</span><br><span class="line">    static ThemeManager *sharedInstance = nil;</span><br><span class="line">    if (sharedInstance == nil)</span><br><span class="line">    &#123;</span><br><span class="line">        sharedInstance = [[ThemeManager alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    return sharedInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主题中的资源使用plist进行存储，颜色的RGBA值跟字体的信息可以直接存入plist，而图片则可以存入图片的位置。按主题命名plist文件，ThemeManager的初始化跟主题更换就从main bundle中按主题名字读取对应的plist文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (id)init</span><br><span class="line">&#123;</span><br><span class="line">    if (self = [super init])</span><br><span class="line">    &#123;</span><br><span class="line">        NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];</span><br><span class="line">        NSString *themeName = [defaults objectForKey:@&quot;theme&quot;] ?: @&quot;default&quot;;</span><br><span class="line"></span><br><span class="line">        NSString *path = [[NSBundle mainBundle] pathForResource:themeName ofType:@&quot;plist&quot;];</span><br><span class="line">        self.theme = [NSDictionary dictionaryWithContentsOfFile:path];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中不再是直接使用主题相关的资源，而是通过ThemeManager得到对应主题下的资源。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 直接使用资源：</span><br><span class="line">UIImage *image = [UIImage imageNamed:@&quot;xxx_btn_background&quot;];</span><br><span class="line">// 通过主题管理器使用资源：</span><br><span class="line">NSDictionary *theme = [ThemeManager sharedInstance].theme;</span><br><span class="line">NSString *imageName = [theme objectForKey:@&quot;xxx_btn_background&quot;];</span><br><span class="line">UIImage *image = [UIImage imageNamed:imageName];</span><br><span class="line">上面的代码在使用时还是有些复杂，代码只关心资源的功能，不关系也不应该关心取资源的细节，因此应在ThemeManager对取资源进行如下封装：</span><br><span class="line"></span><br><span class="line">- (UIImage *)imageForKey:(NSString *)key;</span><br><span class="line">在使用主题中的资源时，代码就变成了：</span><br><span class="line"></span><br><span class="line">UIImage *image = [[ThemeManager sharedInstance] imageForKey:@&quot;xxx_btn_background&quot;];</span><br></pre></td></tr></table></figure>
<h5 id="2-_资源的放置">2. 资源的放置</h5><p>当系统将主题相关的资源文件部署到ios设备中时，在默认情况下，系统会将所有的资源plat平铺拷贝到mainBundle目录下，即使你的资源是按文件夹来组织的。（我们可以在模拟器中查看Bundle的情况，模拟器的路径是：~/Library/Application Support/iPhone Simulator）</p>
<p>因此，在将资源文件加入到工程时，不要选默认的”Recursively create groups for any add folders”，要选择“Create Folder Reference for any add folders”，这样才能保证资源文件按照原有文件夹的组织格式被拷贝到mainBundle中。</p>
<p>关于上述的两个选项，就涉及到Xcode的Group（黄色）跟Folder Reference（蓝色）的概念了，参见从别处摘抄来的理解：</p>
<p>XCode项目中的文件夹分成两类: group 和 directory reference, 分别是虚结构和实结构. 黄颜色的 group 是默认的格式, 它的结构和磁盘上的文件夹毫无关系, 仅仅表示资源的逻辑组织结构, 这在管理源文件是非常方便. 同一段代码可以被很多项目使用, 也可能只使用一个目录的部分文件, 它不需要被拷贝到当前项目中, 但可以在当前项目中保持一个清晰的逻辑结构. 而且引用头文件时不需要指明复杂的层次结构, 因为这些文件在XCode看来是 flat 的, 即它们处在同一层文件夹里.<br>但是 group 带来便利的同时也导致更加棘手的麻烦, 文件重名冲突问题; 尤其当你要使用上千个资源文件时, 这种问题已经极难避免; 而且, 资源文件一般是要拷贝到目标程序中的, 虽然它们在项目中可以有结构的组织, 但是复制到程序中时将会 flat 地输出到程序的根目录中, 这将是怎样的一个灾难! 同时, 如果你在外部向文件夹中加入了上百幅图片, 你不得不把它们再向xcode中加入一遍. 归根结底, 还要求助于我们传统的蓝色的 directory reference。</p>
<h5 id="3-_主题更换通知">3. 主题更换通知</h5><p>对于没有显示的界面，更换主题是不需要通知的，因为在取资源时是根据当前主题取的，但是对于正在显示的界面，更换主题时就需要进行通知，让界面重新取资源后再重绘。由于这类通知是全局性的，因此应该使用NSNotification实现通知机制。</p>
<p>在ThemeManager的changeTheme中调用[NSNotificaitonCenter defaultCenter]的postNotificationName:object:发出通知，而在各个涉及到主题更换的ViewController中使用addObserver:selector:name:object:监听通知事件。</p>
<h5 id="4-_总结">4. 总结</h5><p>其实主题的设计思路跟类簇很像，例如对于NSNumber，不同类型的数据其实真正返回的是NSNumber相对于此类型的子类，但是对于NSNumber的使用者而言，其并不关心NSNumber返回的具体子类是什么，只要满足NSNumber定义的接口就行。设计总是类似的，针对易变化的部分，增加一个中间层（接口）将易变化的部分封装起来，提供给使用者稳定不易变的服务。</p>
<p>总之，OOP跟DesignPattern在我看来主要做了两件事：</p>
<p>隔离变化<br><br>封装细节</p>
<h5 id="参考">参考</h5><p><a href="http://twinlogix.com/en/blog/how-create-multiple-themes-ios-apps" target="_blank" rel="noopener">HOW TO CREATE MULTIPLE THEMES FOR IOS APPS</a><br><a href="http://blog.csdn.net/yanghua_kobe/article/details/9555575" target="_blank" rel="noopener">iOS开发之主题皮肤</a><br><a href="https://github.com/rnystrom/RNThemeManager" target="_blank" rel="noopener">RNThemeManager</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="原出处：传人的技术博客">原出处：<a href="http://joeshang.github.io/2014/12/22/theme-change-architecture/" target="_blank" rel="noopener">传人的技术博客</a></h4><p>现在App类似桌面软件的趋势，在功能完善之后，渐渐追求个性化，以满足不同用户的审美，主题更换就是其中一项，像Weico微博客户端，UC浏览器。所谓主题，可以看成相同功能不同展现可视资源的集合，例如，按钮无论在什么主题下都需要背景图片这个资源，只是在不同主题下是不同的背景图片而已。<br>]]>
    
    </summary>
    
      <category term="Hexo" scheme="http://tanghongbin.me/categories/Hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在Xcode6里使用矢量图-译]]></title>
    <link href="http://tanghongbin.me/2014/09/22/zai-xcode6li-shi-yong-shi-liang-tu-yi/"/>
    <id>http://tanghongbin.me/2014/09/22/zai-xcode6li-shi-yong-shi-liang-tu-yi/</id>
    <published>2014-09-22T13:03:08.000Z</published>
    <updated>2014-09-22T14:06:45.000Z</updated>
    <content type="html"><![CDATA[<p>原文地址：<a href="http://martiancraft.com/blog/2014/09/vector-images-xcode6/" target="_blank" rel="noopener">http://martiancraft.com/blog/2014/09/vector-images-xcode6/</a><br><br><br><img src="/images/using_vector_image_xcode_1.png" alt="sing_vector_image_xcode_1"><br><a id="more"></a><br><br><br>iOS applications are an image-driven species. When developing an app, you need icons in various sizes, Default.png images in different sizes, and also @1x and @2x images for each image file inside the app. All of these images make applications look attractive, but the downside is you have to generate these image files individually. With the introduction of the iPhone 6 and 6 Plus last week, I couldn’t help but think how difficult it will be to manage yet another group of assets: @3x assets.<br><br><br>iOS应用是一种图片驱动类型的应用。当开发一款应用的时候，在整个应用里面，你需要各种各样尺寸的icons，不同尺寸的Default.png，以及每一张图片都需要@1x，@2x两个版本。所有的这些图片令到你的应用看起来很吸引人，但不足之处在于你必须分别生成这些图片。随着上周对iPhone6、iPhone6 plus的介绍，我不由地觉得管理另一个图片资源：@3x会是多么的困难。<br><br><br>Fortunately, Apple has provided some great tools in Xcode 6 for managing assets. Even better, this a way to prepare your apps for future iOS devices. One piece of this is the ability to generate Storyboard-based Launch Images in Xcode 6 and iOS 8, leaving behind the notion of individual images for each device type. Another piece of this technology is the ability to generate vector-based images from a PDF at build-time in Xcode 6. In this article, I want to delve into how you can do the latter, saving yourself time (and your sanity) in the process.<br><br><br>幸运的是，Apple在Xcode6 里面提供了一些很强大的工具去管理这些资源，更妙的是，对于未来的iOS设备，这是为你的应用做准备的一种方式。一个是生成Storyboard-based Launch Images，另一个是基于矢量图的PDF文件生成矢量图片，在这篇文章里，我打算深入去研究你需要怎样做到这个，去节省自己的精力。</p>
<p><a href="https://developer.apple.com/videos/wwdc/2014/#411" target="_blank" rel="noopener">Session 411</a> from WWDC “What’s New in Interface Builder” discussed—albeit very briefly—Xcode’s support for creating your PNG files at build time from a vectorized PDF. I share with you exactly how this is done.<br><br><br>在WWDC，很简洁地介绍-Xcode 支持在构建应用的时候为矢量图PDF文件创建格式为PNG的文件，下面我分享给大家如何做。<br><br></p>
<h2 id="Step_1-_Generate_vector_PDFs_in_Illustrator">Step 1. Generate vector PDFs in Illustrator</h2><ul>
<li>第一步，使用Illustrator生成矢量PDF文件<br><br><br><img src="/images/using_vector_image_xcode_2.png" alt="sing_vector_image_xcode_2"> </li>
</ul>
<p>To begin, you’ll need a vector PDF exported from Adobe Illustrator (or your other favorite vector-based drawing tool) at the @1x size you need in your applications. This is very easily done in Illustrator by:<br><br></p>
<ul>
<li>Create a new document with the size of the @1x asset you’ll be exporting.</li>
<li>Place your path in the new document, just as you would normally.</li>
<li>Export by selecting Save from the File menu.</li>
<li><p>Remember to uncheck the ‘Preserve Illustrator Editing Capabilities’ option when saving.<br><br><br>The PDF that gets exported from Illustrator will be a scalable vector, perfectly capable of scaling to the @2x, and @3x resolutions in iOS. Let’s look at how to set this up in Xcode.<br><br><br>开始，你需要从AI到处一份矢量PDF文件（或者其他你习惯使用的矢量图工具），尺寸是在你的应用里的@1x尺寸，在AI里面非常容易做到这个：</p>
</li>
<li><p>用@1x的尺寸创建新的文档</p>
</li>
<li>想平时一样找个地方保存你文档</li>
<li>文件-保存-导出</li>
<li>保存时记的不要勾选Preserve Illustrator Editing Capabilities选项</li>
</ul>
<p><br><br>得到的矢量PDF是可缩放的，完美缩放成@2x、@3x尺寸，下面看在Xcode怎样去配置。<br><br></p>
<h2 id="Step_2-_Set_up_your_Xcode_project">Step 2. Set up your Xcode project</h2><p>In order to use this feature, you’ll need an Xcode Asset to manage your images. Don’t worry, though, you can mix standard image imports and XCAssets without issue. Follow these steps to tell Xcode to use vectors when specifying images:<br><br><br>为了能使用这个特性，你需要一个Xcode 资产目录去管理你的images，不要担心，你能够无缝混合使用标准的image imort和XCAssets，通过这些步骤去告诉Xcode当指定images时使用矢量图。<br><br><br><img src="/images/using_vector_image_xcode_3.png" alt="sing_vector_image_xcode_3"><br><br></p>
<ul>
<li>If you don’t already have an XCAsset file, then create one; otherwise, open one you already have in your project.</li>
<li>Select “New Image Set” from the Editor menu.</li>
<li>In the new image set that appears, select the blank image set, then show the Utilities panel.</li>
<li>Select the Attributes Inspector.</li>
<li>Under the types drop-down menu, select “Vectors”.</li>
<li>The image set will change to just one drop point, labeled “All - Universal”</li>
<li><p>Drag and drop your vector PDF created above onto the drop point.<br><br><br>Next, you’ll simply use the Xcode Image Catalog image set as you would with any other image (either in code or through Interface Builder). For instance, calling -imageNamed: in code, and passing in the NSString literal name of the image set.</p>
</li>
<li><p>如果你还没有XCAsset文件，创建一个，否则打开你已经有的XCAsset file；</p>
</li>
<li>从编辑菜单里选择“New Image Set”</li>
<li>在出现的image set 里面，选中空的image set，打开Utilities panel</li>
<li>选择Attributes Inspector.</li>
<li>在types下拉菜单里选中“vectors”</li>
<li>image set会变成一个，文字是“All - Universal”</li>
<li>拖你创建好的矢量PDF进去<br><br><br>接下来，你可以很容易地使用Xcode Image Catalog image set，无论是IB里，还是代码里，在代码里，你直接使用-imageNamed:，传入image set名字就可以<br><br></li>
</ul>
<h2 id="Step_3-_Watch_the_magic_happen">Step 3. Watch the magic happen</h2><p>When you build your project, Xcode will go to work, creating @1x, @2x, and @3x PNG files from the PDF that you’ve used in the Xcode Asset Catalog. For instance, if you had a @1x PDF that was 150px x 150px, then Xcode will generate the following PNG sizes for use in the application:<br><br><br>@1x PNG at 150px x 150px<br>@2x PNG at 300px x 300px<br>@3x PNG at 450px x 450px<br><br><br>When you run the application, iOS will automatically pick the appropriate @1x, @2x, or @3x image that Xcode generated based on the device requirements. Be sure to specify your AutoLayout constraints so that the image isn’t resized on larger devices, otherwise you’ll end up with blurry images. Xcode generates raster images that are based on the @1x PDF image instead of scaling a vector a run-time.</p>
<p>(意译)<br>当你build你的项目，Xcode会开始工作，自动生成@1x，@2x，@3x三种尺寸的PDG文件，是基于那个PDF文件的，接下来的事，你懂的。<br><br></p>
<h2 id="Notes_about_PDF_support_in_Xcode">Notes about PDF support in Xcode</h2><p>Some notes about this method of adding images to your project:<br>This is not full vector support — PNG images are generated at build-time, and you maintain no control over this.<br><br><br>You cannot choose a new size for the image once you’ve specified to use the vector-scaled image in your app. Stick with the size you’ve specified, or create a new PDF for the larger size. Otherwise, the images will be distorted if you scale with AutoLayout, for instance.<br>While iOS 8 doesn’t include full vector support (rather Xcode just builds your PNGs at build-time) — OS X does — if you use this same method. In OS X, you can scale your image in code or using AutoLayout without any distortion.<br><br><br>There is no backwards compatibility with previous iOS versions.<br>If you already have a script or other tool that does this automatically for you, then you might not see a benefit in using this method of auto-PNG generation; however, if you use shared assets between OS X and iOS apps, it could be a handy tool.<br><br></p>
<h2 id="More_information_and_resources">More information and resources</h2><p><a href="https://developer.apple.com/videos/wwdc/2014/#411" target="_blank" rel="noopener">WWDC ‘14 Session 411</a><br><br><br><a href="https://developer.apple.com/library/ios/recipes/xcode_help-image_catalog-1.0/Recipe.html" target="_blank" rel="noopener">Apple Developer Asset Catalog Guide</a><br><br><br><a href="https://developer.apple.com/library/ios/recipes/xcode_help-interface_builder/chapters/AboutInterfaceBuilder.html#//apple_ref/doc/uid/TP40009971-CH38-SW1" target="_blank" rel="noopener">Apple Developer Interface Builder Guide</a><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文地址：<a href="http://martiancraft.com/blog/2014/09/vector-images-xcode6/" target="_blank" rel="noopener">http://martiancraft.com/blog/2014/09/vector-images-xcode6/</a><br><br><br><img src="/images/using_vector_image_xcode_1.png" alt="sing_vector_image_xcode_1"><br>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://tanghongbin.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[实现UISearchDisplayController 默认显示初始数据UITableView效果]]></title>
    <link href="http://tanghongbin.me/2014/09/21/shi-xian-uisearchdisplaycontroller-mo-ren-xian-shi-chu-shi-shu-ju-uitableviewxiao-guo/"/>
    <id>http://tanghongbin.me/2014/09/21/shi-xian-uisearchdisplaycontroller-mo-ren-xian-shi-chu-shi-shu-ju-uitableviewxiao-guo/</id>
    <published>2014-09-20T19:12:51.000Z</published>
    <updated>2018-03-23T02:47:18.559Z</updated>
    <content type="html"><![CDATA[<h4 id="实现UISearchDisplayController_默认显示初始数据UITableView效果">实现UISearchDisplayController 默认显示初始数据UITableView效果</h4><p>最近做的项目需要实现类似iOS版 QQ的联系人搜索一样效果的搜索功能，就是UISearchDisplayController通过UISearchBar激活搜索状态后，会首先显示一个搜索历史的列表，当然前提是有搜索历史系统默认的UISearchDisplayController自带一个searchResultTableView，看命名就知道系统是希望我们会用来显示搜索结果的，而且它在UISearchBar没输入任何内容之前是不显示的。</p>
<a id="more"></a>
<ul>
<li>先看效果：</li>
</ul>
<p><img src="/images/searchDisplayController_1.png" alt="searchDisplayController_1"> <img src="/images/searchDisplayController_2.png" alt="searchDisplayController_2"></p>
<ul>
<li><p>实现这个效果，很多人首先会进入一个误区，就是会想着进来一显示的那个UITablView就是UISearchDisplayController的searchResultTableView，其实不然，只要思维走出这误区，接下来的事情就很容易了。<br>事实上，我是另外新建了一个UITableView作为searchRecordTableView，在激活搜索之后，默认显示搜索记录，当用户开始搜索，隐藏搜索历史记录列表，让searchResultTableView显示出来，这就是基本思路，说得挺简单，实现起来也简单，只是有几个地方要注意：<br><br></p>
</li>
<li><p>searchRecordTableView要添加到 controller.searchContentsController.view 的 subviews</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)searchDisplayControllerDidBeginSearch:(<span class="built_in">UISearchDisplayController</span> *)controller</span><br><span class="line">&#123;</span><br><span class="line">    [controller.searchContentsController.view addSubview:_recordTableView];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)searchBar:(<span class="built_in">UISearchBar</span> *)searchBar textDidChange:(<span class="built_in">NSString</span> *)searchText</span><br><span class="line">&#123;</span><br><span class="line">    _searchText = searchText;</span><br><span class="line">    <span class="keyword">if</span> ([searchText length] &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">        [_recordTableView removeFromSuperview];</span><br><span class="line">        <span class="meta">#warning 请求搜索补全</span></span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        [_recordTableView reloadData];</span><br><span class="line">        [<span class="keyword">self</span>.searchDisplayController.searchContentsController.view addSubview:_recordTableView];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><br></p>
<ul>
<li>searchRecordTableView 的 Frame</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_recordTableView = [[<span class="built_in">UITableView</span> alloc]initWithFrame:<span class="string">"基于searchBar的frame来控制"</span> style:<span class="built_in">UITableViewStylePlain</span>];</span><br></pre></td></tr></table></figure>
<ul>
<li>两个UITableView可以使用同一个UITablViewDelegate,UITableViewDataSource，只要在具体函数里面做做处理。</li>
<li>具体代码:    <a href="https://github.com/thongbin/TBSearchViewController" target="_blank" rel="noopener">Github</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="实现UISearchDisplayController_默认显示初始数据UITableView效果">实现UISearchDisplayController 默认显示初始数据UITableView效果</h4><p>最近做的项目需要实现类似iOS版 QQ的联系人搜索一样效果的搜索功能，就是UISearchDisplayController通过UISearchBar激活搜索状态后，会首先显示一个搜索历史的列表，当然前提是有搜索历史系统默认的UISearchDisplayController自带一个searchResultTableView，看命名就知道系统是希望我们会用来显示搜索结果的，而且它在UISearchBar没输入任何内容之前是不显示的。</p>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://tanghongbin.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[static关键字和const关键字]]></title>
    <link href="http://tanghongbin.me/2014/07/24/staticguan-jian-zi-he-constguan-jian-zi/"/>
    <id>http://tanghongbin.me/2014/07/24/staticguan-jian-zi-he-constguan-jian-zi/</id>
    <published>2014-07-24T02:04:52.000Z</published>
    <updated>2015-08-20T19:38:45.000Z</updated>
    <content type="html"><![CDATA[<p>这两个关键字平时可能用得比较多，但有时还是会记不住他们的用法，特此记录一下</p>
<h2 id="static">static</h2><p>直接说它的作用可能会更直观，使用static关键字修饰的变量：</p>
<ul>
<li>称为静态变量，当你是在程序开始时就创建了它，那么它整个生命周期是从程序开始到结束，也就说在程序结束之前，会一直占着内存，系统不会释放。</li>
<li>只会初始化一次</li>
<li>适用于只需初始化一次的变量，例如记录页面的访问次数、操作次数等。</li>
</ul>
<h2 id="const">const</h2><ul>
<li>常量，初始化了就不能修改的</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>这两个关键字平时可能用得比较多，但有时还是会记不住他们的用法，特此记录一下</p>
<h2 id="static">static</h2><p>直接说它的作用可能会更直观，使用static关键字修饰的变量：</p>
<ul>
<li>称为静态变量，当你是在程序开始时就创建了]]>
    </summary>
    
      <category term="iOS" scheme="http://tanghongbin.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Grand Central Dispatch(GCD)]]></title>
    <link href="http://tanghongbin.me/2014/07/21/grand-central-dispath-gcd-xue-xi/"/>
    <id>http://tanghongbin.me/2014/07/21/grand-central-dispath-gcd-xue-xi/</id>
    <published>2014-07-21T06:18:09.000Z</published>
    <updated>2018-03-23T09:23:46.037Z</updated>
    <content type="html"><![CDATA[<p>Grand Central Dispatch 简称GCD，苹果在Mac OS X 10.6 ，iOS 4平台首次发布，后续平台也可用。GCD是一组用C语言封装的多线程技术API。</p>
<p>关于GCD的更多信息，参考<a href="https://developer.apple.com/library/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/Reference/reference.html#//apple_ref/doc/uid/TP40008079-CH1-SW1" target="_blank" rel="noopener">官方文档</a>。</p>
<a id="more"></a>
<h3 id="特性">特性</h3><ul>
<li>基于队列工作 dispatch queue，严格按照FIFO（first in first out）</li>
<li>平行排队特定任务</li>
<li>利用任何可用核心资源（多核处理器）处理任务</li>
<li>任务：函数（function）、block</li>
</ul>
<h3 id="队列">队列</h3><h3 id="Serial_-_Serial_dispatch_queues">Serial - Serial dispatch queues</h3><ul>
<li>串行队列，多个serial queue之间同步并发执行，串行fifo队列，适合用于按指定顺序执行的任务，保持线程安全，串行同步安全地访问资源，在应用程序里面，必须明确指定串行队列，可以已根据需要创建足够多的，但不要用serial queue 代替 concurrent queue 处理任务庞大的任务。</li>
<li>一次执行一个任务，按添加顺序执行</li>
<li>每个任务只会在前一个任务完成之后才开始执行</li>
<li>任务执行之间的时间间隔不明朗，完全靠GCD本身调度</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_create(<span class="string">"me.tanghongbin"</span>, DISPATCH_QUEUE_SERIAL)</span><br></pre></td></tr></table></figure>
<h4 id="Main_dispatch_queue(属于serial_queue)">Main dispatch queue(属于serial queue)</h4><ul>
<li>主线程 queue ，串行队列，在主线程上执行任务，用来更新ui</li>
<li>main thread 有系统自动创建，并会自动关联上你的应用的主线程</li>
</ul>
<p>可使用 <code>dispatch_get_main_queue</code> 方式获取：</p>
<h3 id="Concurrent_-_Global_dispatch_queue">Concurrent - Global dispatch queue</h3><ul>
<li>并行队列，任务从队列被列出是按FIFO规则的，但是会并行执行</li>
<li>执行完成的顺序是随机的</li>
<li>适合并行处理数量庞大的任务，GCD可以提供四种此类并行队列，只通过各自的优先级不同去区别开来。</li>
<li>注意，因为是全局队列，所以系统同时也在使用这些队列</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue;</span><br><span class="line">queue = dispatch_queue_create(<span class="string">"me.tanghongbin"</span>, DISPATCH_QUEUE_SERIAL)</span><br><span class="line"></span><br><span class="line">queue = dispatch_get_global_queue(&lt;<span class="meta">#dispatch_queue_priority_t priority#&gt;, <span class="meta-string">&lt;#unsigned long flags#&gt;</span>)</span></span><br><span class="line"></span><br><span class="line">dispatch_queue_priority_t&#123;</span><br><span class="line">	DISPATCH_QUEUE_PRIORITY_HIGH</span><br><span class="line">	DISPATCH_QUEUE_PRIORITY_DEFAULT</span><br><span class="line">	DISPATCH_QUEUE_PRIORITY_LOW</span><br><span class="line">	DISPATCH_QUEUE_PRIORITY_BACKGROUND</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Custom_Queue_自定义队列">Custom Queue 自定义队列</h3><ul>
<li>根据需要自创建队列，串行的或者并发的</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">dispath_creat_queue(<span class="string">"me.tanghongbin.custom.queue"</span>,dispath_queue_sttr_t att)</span><br><span class="line"></span><br><span class="line">dispath_queue_sttr_t &#123;</span><br><span class="line">	DISPATCH_QUEUE_SERIAL</span><br><span class="line">	DISPATCH_QUEUE_CONCURRENT</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="使用">使用</h1><h3 id="dispatch_sync">dispatch_sync</h3><ul>
<li>同步提交任务到一个执行队列，表示是一个同步线程</li>
</ul>
<p>经典列子：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"1"</span>); <span class="comment">// 任务1</span></span><br><span class="line"><span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"2"</span>); <span class="comment">// 任务2 这是一个同步线程任务</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"3"</span>); <span class="comment">// 任务3</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>(输出结果)</span><br></pre></td></tr></table></figure>
<p>分析：例子中 <code>任务1</code>，<code>任务3</code> 都是在 <code>main_queue</code> 上同步执行的，执行顺序是 <code>任务1</code>、阻塞当前线程添加 <code>任务2</code>（并没开始执行）、<code>任务3</code>，<code>任务1</code> 先执行，输出<code>1</code>，线程被阻塞，但是 <code>任务2</code> 是排在 <code>任务3</code> 后面，要等 <code>任务3</code> 执行完才会执行，由于使用 <code>dispatch_sync</code> 了，所以 <code>任务3</code> 要等 <code>dispatch_sync</code> 任务完成后才能执行，互相等待，便成死锁。<br><!-- 例子https://hit-alibaba.github.io/interview/iOS/Cocoa-Touch/Multithreading.html --></p>
<h3 id="dispatch_async">dispatch_async</h3><ul>
<li>提交一个<code>任务</code>到一个异步执行的队列，执行完成后马上返回，不需要等待<code>任务</code>是否执行完毕</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Submits a block <span class="keyword">for</span> asynchronous execution on a dispatch queue and returns immediately.</span><br><span class="line"></span><br><span class="line">   <span class="keyword">void</span> <span class="built_in">dispatch_async</span>(</span><br><span class="line">   <span class="built_in">dispatch_queue_t</span> queue,</span><br><span class="line">   dispatch_block_t block);</span><br></pre></td></tr></table></figure>
<h4 id="queue">queue</h4><ul>
<li>block提交得目标队列，在block执行完成之前，系统会保留这个queue，值不能为Null</li>
</ul>
<h4 id="block">block</h4><ul>
<li>队列执行的目标block，方法会自动执行Block_copy和Block_release，值不能为Null</li>
</ul>
<p>提交bolck到dispatch_queue最基本的方法，队列决定block执行的方式，串行或者并行，当然了，是异步的。</p>
<h3 id="常用的方法">常用的方法</h3><p>我们在处理一些耗时操作时，比如网络读取数据、预服务器交互、数据库读写、io等，有时执行时间过长会导致主界面有卡顿的甚至卡死的情况出现，当然这种情况可以使用NSThread、NSOperation解决，但使用dispatch_async更简单：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="comment">// 耗时的操作，读取数据、数据处理等操作</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="comment">// 更新界面，dispatch_get_main_queue()是切换回主线程队列的方法</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="dispatch_group_async">dispatch_group_async</h3><ul>
<li>以组的方式关联一组block，等block都执行完成，就发起完成的通知，<code>group里面的block是并行执行的</code>。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Submits a block to a dispatch queue and associates the block with the specified dispatch group.</span><br><span class="line"></span><br><span class="line">   <span class="keyword">void</span> dispatch_group_async(</span><br><span class="line">   dispatch_group_t group,</span><br><span class="line">   <span class="built_in">dispatch_queue_t</span> queue,</span><br><span class="line">   dispatch_block_t block);</span><br></pre></td></tr></table></figure>
<h4 id="使用例子">使用例子</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"group1"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"group2"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"group3"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"updateUi"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_release(group);<span class="comment">//释放group</span></span><br></pre></td></tr></table></figure>
<p>这里面最后还调用了dispatch_group_notify，因为前面提交的block都被关联到同一个group里面，当group里面的block都执行完成后，就需要调用dispatch_group_notify做收尾。</p>
<h3 id="dispatch_once">dispatch_once</h3><ul>
<li><code>dispatch_once</code> 执行一个区块对象，在整个应用的生命周期只执行一次，非常适合用于已单列模式创建全局的对象。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Executes a block object once and only once <span class="keyword">for</span> the lifetime of an application.<span class="comment">//官方解释</span></span><br><span class="line">   <span class="keyword">void</span> <span class="built_in">dispatch_once</span>(</span><br><span class="line">   <span class="built_in">dispatch_once_t</span> *predicate,</span><br><span class="line">   dispatch_block_t block);</span><br><span class="line"><span class="comment">//   example</span></span><br><span class="line">	+(<span class="keyword">instancetype</span>)shareDefaultManager</span><br><span class="line">	&#123;</span><br><span class="line">    <span class="keyword">static</span> TBReachabilityManager *_tbDefaultManager = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> once_t;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;once_t, ^()&#123;</span><br><span class="line">         _tbDefaultManager = [[<span class="keyword">self</span> alloc]init];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  	<span class="keyword">return</span> _tbDefaultManager;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="dispatch_apply">dispatch_apply</h3><ul>
<li>多次执行传入的block</li>
<li>相当于并发执行任务的for</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Submits a block to a dispatch queue <span class="keyword">for</span> multiple invocations.</span><br><span class="line"></span><br><span class="line">   <span class="keyword">void</span> dispatch_apply(</span><br><span class="line">   size_t iterations,</span><br><span class="line">   <span class="built_in">dispatch_queue_t</span> queue,</span><br><span class="line">   <span class="keyword">void</span> (^block)(</span><br><span class="line">   size_t));</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_apply(<span class="number">10</span>, global, ^(size_t index) &#123;</span><br><span class="line">    <span class="comment">// 执行10次</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="dispatch_semaphore">dispatch_semaphore</h3><p>信号量，可以用来解决线程安全的问题，主要是三个方法：</p>
<p><code>dispatch_semaphore_creat</code> 创建一个信号量对象</p>
<p><code>dispatch_semaphore_signal</code> 发送信号，信号量+1</p>
<p><code>dispatch_semaphore_wait</code> 等待信号，信号量-1</p>
<p>第一个函数有一个整形的参数，我们可以理解为信号的总量，<code>dispatch_semaphore_signal</code>是发送一个信号，自然会让信号总量加1，<code>dispatch_semaphore_wait</code>等待信号，当信号总量少于0的时候就会一直等待，否则就可以正常的执行，并让信号总量-1，根据这样的原理，我们便可以快速的创建一个并发控制来同步任务和有限资源访问控制</p>
<h4 id="实际应用">实际应用</h4><p>等待网络请求异步回调callback才继续后面业务：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">_block <span class="built_in">BOOL</span> isok = <span class="literal">NO</span>;  </span><br><span class="line"></span><br><span class="line">    dispatch_semaphore_t sema = dispatch_semaphore_create(<span class="number">0</span>);  </span><br><span class="line">    Engine *engine = [[Engine alloc] init];  </span><br><span class="line">    [engine queryCompletion:^(<span class="built_in">BOOL</span> isOpen) &#123;  </span><br><span class="line">        isok = isOpen;  </span><br><span class="line">        dispatch_semaphore_signal(sema);  </span><br><span class="line">    &#125; onError:^(<span class="keyword">int</span> errorCode, <span class="built_in">NSString</span> *errorMessage) &#123;  </span><br><span class="line">        isok = <span class="literal">NO</span>;  </span><br><span class="line">        dispatch_semaphore_signal(sema);  </span><br><span class="line">    &#125;];  </span><br><span class="line"></span><br><span class="line">    dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER);  </span><br><span class="line">    <span class="comment">// todo what you want to do after net callback</span></span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Grand Central Dispatch 简称GCD，苹果在Mac OS X 10.6 ，iOS 4平台首次发布，后续平台也可用。GCD是一组用C语言封装的多线程技术API。</p>
<p>关于GCD的更多信息，参考<a href="https://developer.apple.com/library/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/Reference/reference.html#//apple_ref/doc/uid/TP40008079-CH1-SW1" target="_blank" rel="noopener">官方文档</a>。</p>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://tanghongbin.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[初识iOS]]></title>
    <link href="http://tanghongbin.me/2014/07/18/chu-shi-ios/"/>
    <id>http://tanghongbin.me/2014/07/18/chu-shi-ios/</id>
    <published>2014-07-18T06:31:59.000Z</published>
    <updated>2015-08-20T19:37:42.000Z</updated>
    <content type="html"><![CDATA[<h4 id="简介：">简介：</h4><p>iOS（原名：iPhone OS）是由苹果公司为移动设备所开发的操作系统，支持的设备包括iPhone、iPod touch、iPad、Apple TV。与Android及Windows Phone不同，iOS不支持非苹果硬件的设备。系统操作（iOS 7）占用约700-900MB左右的储存空间(其中iPhone、iPod touch占约700MB，iPad占约900MB）。目前，iOS的最新版本为8.0 beta。<br><br></p>
<h4 id="系统架构">系统架构</h4><ul>
<li>框架：iOS使用基于与苹果麦金塔计算器不同的ARM架构的64位或32位中央处理器，使用由PowerVR视频卡渲染的OpenGL ES 3.0以Darwin作为基础[8][9]。</li>
<li>系统架构层次：核心操作系统层（the Core OS layer），核心服务层（the Core Services layer），媒体层（the Media layer），触控应用层（the Cocoa Touch layer）<br><br></li>
</ul>
<p>其实以上的资料都可以在网上找到的，就不摘录了，直接点，想进入iOS开发的世界，可以<a id="more"></a>先攻陷以下几本书：</p>
<ul>
<li><p><a href="http://product.dangdang.com/22881807.html#ddclick?act=click&amp;pos=22881807_0_1_q&amp;cat=&amp;key=objective-c&amp;qinfo=95_1_60&amp;pinfo=&amp;minfo=&amp;ninfo=&amp;custid=&amp;permid=20140512153454357427378240331150676&amp;ref=http%3A%2F%2Fproduct.dangdang.com%2F23312312.html&amp;rcount=&amp;type=&amp;t=1405669671000&amp;ver=A" target="_blank" rel="noopener">《Objective-C 程序设计 第四版》</a></p>
</li>
<li><p><a href="http://product.dangdang.com/23312312.html#ddclick?act=click&amp;pos=23312312_1_1_q&amp;cat=&amp;key=ios&amp;qinfo=821_1_60&amp;pinfo=&amp;minfo=&amp;ninfo=&amp;custid=&amp;permid=20140512153454357427378240331150676&amp;ref=http%3A%2F%2Fv.dangdang.com%2F&amp;rcount=&amp;type=&amp;t=1405669571000&amp;ver=A" target="_blank" rel="noopener">《精通iOS开发 第5版》</a><br><br></p>
<h3 id="Apple_在最近的一次WWDC上面发布了最新的Swift语言，具体可以在Cocoachina_Swift这里了解并学习。">Apple 在最近的一次WWDC上面发布了最新的Swift语言，具体可以在<a href="http://www.cocoachina.com/special/swift/" target="_blank" rel="noopener"><code>Cocoachina Swift</code></a>这里了解并学习。</h3></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="简介：">简介：</h4><p>iOS（原名：iPhone OS）是由苹果公司为移动设备所开发的操作系统，支持的设备包括iPhone、iPod touch、iPad、Apple TV。与Android及Windows Phone不同，iOS不支持非苹果硬件的设备。系统操作（iOS 7）占用约700-900MB左右的储存空间(其中iPhone、iPod touch占约700MB，iPad占约900MB）。目前，iOS的最新版本为8.0 beta。<br><br></p>
<h4 id="系统架构">系统架构</h4><ul>
<li>框架：iOS使用基于与苹果麦金塔计算器不同的ARM架构的64位或32位中央处理器，使用由PowerVR视频卡渲染的OpenGL ES 3.0以Darwin作为基础[8][9]。</li>
<li>系统架构层次：核心操作系统层（the Core OS layer），核心服务层（the Core Services layer），媒体层（the Media layer），触控应用层（the Cocoa Touch layer）<br><br></li>
</ul>
<p>其实以上的资料都可以在网上找到的，就不摘录了，直接点，想进入iOS开发的世界，可以]]>
    
    </summary>
    
      <category term="iOS" scheme="http://tanghongbin.me/categories/iOS/"/>
    
  </entry>
  
</feed>

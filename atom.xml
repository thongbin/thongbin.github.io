<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Kelvin Tong]]></title>
  <subtitle><![CDATA[S.H.S.F]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2015-08-20T19:57:40.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Kelvin]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[[转载]主题更换设计思路]]></title>
    <link href="http://yoursite.com/2015/08/20/zhu-ti-geng-huan-she-ji-si-lu/"/>
    <id>http://yoursite.com/2015/08/20/zhu-ti-geng-huan-she-ji-si-lu/</id>
    <published>2015-08-20T10:17:41.000Z</published>
    <updated>2015-08-20T19:57:40.000Z</updated>
    <content type="html"><![CDATA[<h4 id="原出处：传人的技术博客">原出处：<a href="http://joeshang.github.io/2014/12/22/theme-change-architecture/" target="_blank" rel="external">传人的技术博客</a></h4><p>现在App类似桌面软件的趋势，在功能完善之后，渐渐追求个性化，以满足不同用户的审美，主题更换就是其中一项，像Weico微博客户端，UC浏览器。所谓主题，可以看成相同功能不同展现可视资源的集合，例如，按钮无论在什么主题下都需要背景图片这个资源，只是在不同主题下是不同的背景图片而已。<br><a id="more"></a><br>如何在iOS中实现主题更换的核心思路为：</p>
<p>资源按主题放置：相同功能的资源名称相同，放在不同的主题路径或者前缀使用主题名。<br>增加中间层，隔离不同主题相同功能资源使用的变化。</p>
<h5 id="1-_主题管理">1. 主题管理</h5><p>主题的特性导致代码不关心资源的表现是什么，只关心资源的功能，而主题是易变化的，因此需要将易变化的部分抽离出来，整合到一个管理者中，主题的变化在管理者中完成，而不影响资源使用的地方。而且这个管理者是全局唯一的，因此使用单例。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ <span class="list">(<span class="keyword">ThemeManager</span> <span class="variable">*)sharedInstance</span><br><span class="line">&#123;</span><br><span class="line">    static ThemeManager *</span>sharedInstance = <span class="literal">nil</span><span class="comment">;</span></span><br><span class="line">    if <span class="list">(<span class="keyword">sharedInstance</span> == <span class="literal">nil</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        sharedInstance = [[ThemeManager alloc] init]<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    return sharedInstance<span class="comment">;</span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>主题中的资源使用plist进行存储，颜色的RGBA值跟字体的信息可以直接存入plist，而图片则可以存入图片的位置。按主题命名plist文件，ThemeManager的初始化跟主题更换就从main bundle中按主题名字读取对应的plist文件。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSUserDefaults</span> *defaults = [<span class="built_in">NSUserDefaults</span> standardUserDefaults];</span><br><span class="line">        <span class="built_in">NSString</span> *themeName = [defaults objectForKey:<span class="string">@"theme"</span>] ?: <span class="string">@"default"</span>;</span><br><span class="line">                                            </span><br><span class="line">        <span class="built_in">NSString</span> *path = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:themeName ofType:<span class="string">@"plist"</span>];</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.theme</span> = [<span class="built_in">NSDictionary</span> dictionaryWithContentsOfFile:path];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中不再是直接使用主题相关的资源，而是通过ThemeManager得到对应主题下的资源。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接使用资源：</span></span><br><span class="line"><span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"xxx_btn_background"</span>];</span><br><span class="line"><span class="comment">// 通过主题管理器使用资源：</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *theme = [ThemeManager sharedInstance]<span class="variable">.theme</span>;</span><br><span class="line"><span class="built_in">NSString</span> *imageName = [theme objectForKey:<span class="string">@"xxx_btn_background"</span>];</span><br><span class="line"><span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:imageName];</span><br><span class="line">上面的代码在使用时还是有些复杂，代码只关心资源的功能，不关系也不应该关心取资源的细节，因此应在ThemeManager对取资源进行如下封装：</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UIImage</span> *)imageForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">在使用主题中的资源时，代码就变成了：</span><br><span class="line"></span><br><span class="line"><span class="built_in">UIImage</span> *image = [[ThemeManager sharedInstance] imageForKey:<span class="string">@"xxx_btn_background"</span>];</span><br></pre></td></tr></table></figure>
<h5 id="2-_资源的放置">2. 资源的放置</h5><p>当系统将主题相关的资源文件部署到ios设备中时，在默认情况下，系统会将所有的资源plat平铺拷贝到mainBundle目录下，即使你的资源是按文件夹来组织的。（我们可以在模拟器中查看Bundle的情况，模拟器的路径是：~/Library/Application Support/iPhone Simulator）</p>
<p>因此，在将资源文件加入到工程时，不要选默认的”Recursively create groups for any add folders”，要选择“Create Folder Reference for any add folders”，这样才能保证资源文件按照原有文件夹的组织格式被拷贝到mainBundle中。</p>
<p>关于上述的两个选项，就涉及到Xcode的Group（黄色）跟Folder Reference（蓝色）的概念了，参见从别处摘抄来的理解：</p>
<p>XCode项目中的文件夹分成两类: group 和 directory reference, 分别是虚结构和实结构. 黄颜色的 group 是默认的格式, 它的结构和磁盘上的文件夹毫无关系, 仅仅表示资源的逻辑组织结构, 这在管理源文件是非常方便. 同一段代码可以被很多项目使用, 也可能只使用一个目录的部分文件, 它不需要被拷贝到当前项目中, 但可以在当前项目中保持一个清晰的逻辑结构. 而且引用头文件时不需要指明复杂的层次结构, 因为这些文件在XCode看来是 flat 的, 即它们处在同一层文件夹里.<br>但是 group 带来便利的同时也导致更加棘手的麻烦, 文件重名冲突问题; 尤其当你要使用上千个资源文件时, 这种问题已经极难避免; 而且, 资源文件一般是要拷贝到目标程序中的, 虽然它们在项目中可以有结构的组织, 但是复制到程序中时将会 flat 地输出到程序的根目录中, 这将是怎样的一个灾难! 同时, 如果你在外部向文件夹中加入了上百幅图片, 你不得不把它们再向xcode中加入一遍. 归根结底, 还要求助于我们传统的蓝色的 directory reference。</p>
<h5 id="3-_主题更换通知">3. 主题更换通知</h5><p>对于没有显示的界面，更换主题是不需要通知的，因为在取资源时是根据当前主题取的，但是对于正在显示的界面，更换主题时就需要进行通知，让界面重新取资源后再重绘。由于这类通知是全局性的，因此应该使用NSNotification实现通知机制。</p>
<p>在ThemeManager的changeTheme中调用[NSNotificaitonCenter defaultCenter]的postNotificationName:object:发出通知，而在各个涉及到主题更换的ViewController中使用addObserver:selector:name:object:监听通知事件。</p>
<h5 id="4-_总结">4. 总结</h5><p>其实主题的设计思路跟类簇很像，例如对于NSNumber，不同类型的数据其实真正返回的是NSNumber相对于此类型的子类，但是对于NSNumber的使用者而言，其并不关心NSNumber返回的具体子类是什么，只要满足NSNumber定义的接口就行。设计总是类似的，针对易变化的部分，增加一个中间层（接口）将易变化的部分封装起来，提供给使用者稳定不易变的服务。</p>
<p>总之，OOP跟DesignPattern在我看来主要做了两件事：</p>
<p>隔离变化<br><br>封装细节</p>
<h5 id="参考">参考</h5><p><a href="http://twinlogix.com/en/blog/how-create-multiple-themes-ios-apps" target="_blank" rel="external">HOW TO CREATE MULTIPLE THEMES FOR IOS APPS</a><br><a href="http://blog.csdn.net/yanghua_kobe/article/details/9555575" target="_blank" rel="external">iOS开发之主题皮肤</a><br><a href="https://github.com/rnystrom/RNThemeManager" target="_blank" rel="external">RNThemeManager</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="原出处：传人的技术博客">原出处：<a href="http://joeshang.github.io/2014/12/22/theme-change-architecture/">传人的技术博客</a></h4><p>现在App类似桌面软件的趋势，在功能完善之后，渐渐追求个性化，以满足不同用户的审美，主题更换就是其中一项，像Weico微博客户端，UC浏览器。所谓主题，可以看成相同功能不同展现可视资源的集合，例如，按钮无论在什么主题下都需要背景图片这个资源，只是在不同主题下是不同的背景图片而已。<br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[octopress 写文章]]></title>
    <link href="http://yoursite.com/2015/04/23/octopress-xie-wen-zhang/"/>
    <id>http://yoursite.com/2015/04/23/octopress-xie-wen-zhang/</id>
    <published>2015-04-23T09:39:54.000Z</published>
    <updated>2015-07-26T12:00:50.000Z</updated>
    <content type="html"><![CDATA[<p>生命之氢 Blog <a href="http://shengmingzhiqing.com/blog/octopress-tutorials-toc.html/" target="_blank" rel="external">《Octopress 教程目录》</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>生命之氢 Blog <a href="http://shengmingzhiqing.com/blog/octopress-tutorials-toc.html/" target="_blank" rel="external">《Octopress 教程目录》</a></p]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[在Xcode6里使用矢量图-译]]></title>
    <link href="http://yoursite.com/2014/09/22/zai-xcode6li-shi-yong-shi-liang-tu-yi/"/>
    <id>http://yoursite.com/2014/09/22/zai-xcode6li-shi-yong-shi-liang-tu-yi/</id>
    <published>2014-09-22T13:03:08.000Z</published>
    <updated>2014-09-22T14:06:45.000Z</updated>
    <content type="html"><![CDATA[<p>原文地址：<a href="http://martiancraft.com/blog/2014/09/vector-images-xcode6/" target="_blank" rel="external">http://martiancraft.com/blog/2014/09/vector-images-xcode6/</a><br><br><br><img src="/images/using_vector_image_xcode_1.png" alt="sing_vector_image_xcode_1"><br><a id="more"></a><br><br><br>iOS applications are an image-driven species. When developing an app, you need icons in various sizes, Default.png images in different sizes, and also @1x and @2x images for each image file inside the app. All of these images make applications look attractive, but the downside is you have to generate these image files individually. With the introduction of the iPhone 6 and 6 Plus last week, I couldn’t help but think how difficult it will be to manage yet another group of assets: @3x assets.<br><br><br>iOS应用是一种图片驱动类型的应用。当开发一款应用的时候，在整个应用里面，你需要各种各样尺寸的icons，不同尺寸的Default.png，以及每一张图片都需要@1x，@2x两个版本。所有的这些图片令到你的应用看起来很吸引人，但不足之处在于你必须分别生成这些图片。随着上周对iPhone6、iPhone6 plus的介绍，我不由地觉得管理另一个图片资源：@3x会是多么的困难。<br><br><br>Fortunately, Apple has provided some great tools in Xcode 6 for managing assets. Even better, this a way to prepare your apps for future iOS devices. One piece of this is the ability to generate Storyboard-based Launch Images in Xcode 6 and iOS 8, leaving behind the notion of individual images for each device type. Another piece of this technology is the ability to generate vector-based images from a PDF at build-time in Xcode 6. In this article, I want to delve into how you can do the latter, saving yourself time (and your sanity) in the process.<br><br><br>幸运的是，Apple在Xcode6 里面提供了一些很强大的工具去管理这些资源，更妙的是，对于未来的iOS设备，这是为你的应用做准备的一种方式。一个是生成Storyboard-based Launch Images，另一个是基于矢量图的PDF文件生成矢量图片，在这篇文章里，我打算深入去研究你需要怎样做到这个，去节省自己的精力。</p>
<p><a href="https://developer.apple.com/videos/wwdc/2014/#411" target="_blank" rel="external">Session 411</a> from WWDC “What’s New in Interface Builder” discussed—albeit very briefly—Xcode’s support for creating your PNG files at build time from a vectorized PDF. I share with you exactly how this is done.<br><br><br>在WWDC，很简洁地介绍-Xcode 支持在构建应用的时候为矢量图PDF文件创建格式为PNG的文件，下面我分享给大家如何做。<br><br></p>
<h2 id="Step_1-_Generate_vector_PDFs_in_Illustrator">Step 1. Generate vector PDFs in Illustrator</h2><ul>
<li>第一步，使用Illustrator生成矢量PDF文件<br><br><br><img src="/images/using_vector_image_xcode_2.png" alt="sing_vector_image_xcode_2"> </li>
</ul>
<p>To begin, you’ll need a vector PDF exported from Adobe Illustrator (or your other favorite vector-based drawing tool) at the @1x size you need in your applications. This is very easily done in Illustrator by:<br><br></p>
<ul>
<li>Create a new document with the size of the @1x asset you’ll be exporting.</li>
<li>Place your path in the new document, just as you would normally.</li>
<li>Export by selecting Save from the File menu.</li>
<li><p>Remember to uncheck the ‘Preserve Illustrator Editing Capabilities’ option when saving.<br><br><br>The PDF that gets exported from Illustrator will be a scalable vector, perfectly capable of scaling to the @2x, and @3x resolutions in iOS. Let’s look at how to set this up in Xcode.<br><br><br>开始，你需要从AI到处一份矢量PDF文件（或者其他你习惯使用的矢量图工具），尺寸是在你的应用里的@1x尺寸，在AI里面非常容易做到这个：</p>
</li>
<li><p>用@1x的尺寸创建新的文档</p>
</li>
<li>想平时一样找个地方保存你文档</li>
<li>文件-保存-导出</li>
<li>保存时记的不要勾选Preserve Illustrator Editing Capabilities选项</li>
</ul>
<p><br><br>得到的矢量PDF是可缩放的，完美缩放成@2x、@3x尺寸，下面看在Xcode怎样去配置。<br><br></p>
<h2 id="Step_2-_Set_up_your_Xcode_project">Step 2. Set up your Xcode project</h2><p>In order to use this feature, you’ll need an Xcode Asset to manage your images. Don’t worry, though, you can mix standard image imports and XCAssets without issue. Follow these steps to tell Xcode to use vectors when specifying images:<br><br><br>为了能使用这个特性，你需要一个Xcode 资产目录去管理你的images，不要担心，你能够无缝混合使用标准的image imort和XCAssets，通过这些步骤去告诉Xcode当指定images时使用矢量图。<br><br><br><img src="/images/using_vector_image_xcode_3.png" alt="sing_vector_image_xcode_3"><br><br></p>
<ul>
<li>If you don’t already have an XCAsset file, then create one; otherwise, open one you already have in your project.</li>
<li>Select “New Image Set” from the Editor menu.</li>
<li>In the new image set that appears, select the blank image set, then show the Utilities panel.</li>
<li>Select the Attributes Inspector.</li>
<li>Under the types drop-down menu, select “Vectors”.</li>
<li>The image set will change to just one drop point, labeled “All - Universal”</li>
<li><p>Drag and drop your vector PDF created above onto the drop point.<br><br><br>Next, you’ll simply use the Xcode Image Catalog image set as you would with any other image (either in code or through Interface Builder). For instance, calling -imageNamed: in code, and passing in the NSString literal name of the image set.</p>
</li>
<li><p>如果你还没有XCAsset文件，创建一个，否则打开你已经有的XCAsset file；</p>
</li>
<li>从编辑菜单里选择“New Image Set”</li>
<li>在出现的image set 里面，选中空的image set，打开Utilities panel</li>
<li>选择Attributes Inspector.</li>
<li>在types下拉菜单里选中“vectors”</li>
<li>image set会变成一个，文字是“All - Universal”</li>
<li>拖你创建好的矢量PDF进去<br><br><br>接下来，你可以很容易地使用Xcode Image Catalog image set，无论是IB里，还是代码里，在代码里，你直接使用-imageNamed:，传入image set名字就可以<br><br></li>
</ul>
<h2 id="Step_3-_Watch_the_magic_happen">Step 3. Watch the magic happen</h2><p>When you build your project, Xcode will go to work, creating @1x, @2x, and @3x PNG files from the PDF that you’ve used in the Xcode Asset Catalog. For instance, if you had a @1x PDF that was 150px x 150px, then Xcode will generate the following PNG sizes for use in the application:<br><br><br>@1x PNG at 150px x 150px<br>@2x PNG at 300px x 300px<br>@3x PNG at 450px x 450px<br><br><br>When you run the application, iOS will automatically pick the appropriate @1x, @2x, or @3x image that Xcode generated based on the device requirements. Be sure to specify your AutoLayout constraints so that the image isn’t resized on larger devices, otherwise you’ll end up with blurry images. Xcode generates raster images that are based on the @1x PDF image instead of scaling a vector a run-time.</p>
<p>(意译)<br>当你build你的项目，Xcode会开始工作，自动生成@1x，@2x，@3x三种尺寸的PDG文件，是基于那个PDF文件的，接下来的事，你懂的。<br><br></p>
<h2 id="Notes_about_PDF_support_in_Xcode">Notes about PDF support in Xcode</h2><p>Some notes about this method of adding images to your project:<br>This is not full vector support — PNG images are generated at build-time, and you maintain no control over this.<br><br><br>You cannot choose a new size for the image once you’ve specified to use the vector-scaled image in your app. Stick with the size you’ve specified, or create a new PDF for the larger size. Otherwise, the images will be distorted if you scale with AutoLayout, for instance.<br>While iOS 8 doesn’t include full vector support (rather Xcode just builds your PNGs at build-time) — OS X does — if you use this same method. In OS X, you can scale your image in code or using AutoLayout without any distortion.<br><br><br>There is no backwards compatibility with previous iOS versions.<br>If you already have a script or other tool that does this automatically for you, then you might not see a benefit in using this method of auto-PNG generation; however, if you use shared assets between OS X and iOS apps, it could be a handy tool.<br><br></p>
<h2 id="More_information_and_resources">More information and resources</h2><p><a href="https://developer.apple.com/videos/wwdc/2014/#411" target="_blank" rel="external">WWDC ‘14 Session 411</a><br><br><br><a href="https://developer.apple.com/library/ios/recipes/xcode_help-image_catalog-1.0/Recipe.html" target="_blank" rel="external">Apple Developer Asset Catalog Guide</a><br><br><br><a href="https://developer.apple.com/library/ios/recipes/xcode_help-interface_builder/chapters/AboutInterfaceBuilder.html#//apple_ref/doc/uid/TP40009971-CH38-SW1" target="_blank" rel="external">Apple Developer Interface Builder Guide</a><br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文地址：<a href="http://martiancraft.com/blog/2014/09/vector-images-xcode6/">http://martiancraft.com/blog/2014/09/vector-images-xcode6/</a><br><br><br><img src="/images/using_vector_image_xcode_1.png" alt="sing_vector_image_xcode_1"><br>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[实现UISearchDisplayController 默认显示初始数据UITableView效果]]></title>
    <link href="http://yoursite.com/2014/09/21/shi-xian-uisearchdisplaycontroller-mo-ren-xian-shi-chu-shi-shu-ju-uitableviewxiao-guo/"/>
    <id>http://yoursite.com/2014/09/21/shi-xian-uisearchdisplaycontroller-mo-ren-xian-shi-chu-shi-shu-ju-uitableviewxiao-guo/</id>
    <published>2014-09-20T19:12:51.000Z</published>
    <updated>2014-09-22T02:37:26.000Z</updated>
    <content type="html"><![CDATA[<p>最近做的项目需要实现类似iOS版 QQ的联系人搜索一样效果的搜索功能，就是UISearchDisplayController通过UISearchBar激活搜索状态后，会首先显示一个搜索历史的列表，当然前提是有搜索历史系统默认的UISearchDisplayController自带一个searchResultTableView，看命名就知道系统是希望我们会用来显示搜索结果的，而且它在UISearchBar没输入任何内容之前是不显示的。</p>
<ul>
<li>先看效果：</li>
</ul>
<p><img src="/images/searchDisplayController_1.png" alt="searchDisplayController_1"> <img src="/images/searchDisplayController_2.png" alt="searchDisplayController_2"></p>
<a id="more"></a>
<ul>
<li><p>实现这个效果，很多人首先会进入一个误区，就是会想着进来一显示的那个UITablView就是UISearchDisplayController的searchResultTableView，其实不然，只要思维走出这误区，接下来的事情就很容易了。<br>事实上，我是另外新建了一个UITableView作为searchRecordTableView，在激活搜索之后，默认显示搜索记录，当用户开始搜索，隐藏搜索历史记录列表，让searchResultTableView显示出来，这就是基本思路，说得挺简单，实现起来也简单，只是有几个地方要注意：<br><br></p>
</li>
<li><p>searchRecordTableView要添加到 controller.searchContentsController.view 的 subviews</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)searchDisplayControllerDidBeginSearch:(<span class="built_in">UISearchDisplayController</span> *)controller</span><br><span class="line">&#123;</span><br><span class="line">    [controller<span class="variable">.searchContentsController</span><span class="variable">.view</span> addSubview:_recordTableView];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)searchBar:(<span class="built_in">UISearchBar</span> *)searchBar textDidChange:(<span class="built_in">NSString</span> *)searchText</span><br><span class="line">&#123;</span><br><span class="line">    _searchText = searchText;</span><br><span class="line">    <span class="keyword">if</span> ([searchText length] &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">        [_recordTableView removeFromSuperview];</span><br><span class="line">        <span class="preprocessor">#warning 请求搜索补全</span></span><br><span class="line">        </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        [_recordTableView reloadData];</span><br><span class="line">        [<span class="keyword">self</span><span class="variable">.searchDisplayController</span><span class="variable">.searchContentsController</span><span class="variable">.view</span> addSubview:_recordTableView];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><br></p>
<ul>
<li>searchRecordTableView 的 Frame</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_recordTableView = [[<span class="built_in">UITableView</span> alloc]initWithFrame:<span class="string">"基于searchBar的frame来控制"</span> style:<span class="built_in">UITableViewStylePlain</span>];</span><br></pre></td></tr></table></figure>
<ul>
<li>两个UITableView可以使用同一个UITablViewDelegate,UITableViewDataSource，只要在具体函数里面做做处理。</li>
<li>具体代码:    <a href="https://github.com/thongbin/TBSearchViewController" target="_blank" rel="external">Github</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近做的项目需要实现类似iOS版 QQ的联系人搜索一样效果的搜索功能，就是UISearchDisplayController通过UISearchBar激活搜索状态后，会首先显示一个搜索历史的列表，当然前提是有搜索历史系统默认的UISearchDisplayController自带一个searchResultTableView，看命名就知道系统是希望我们会用来显示搜索结果的，而且它在UISearchBar没输入任何内容之前是不显示的。</p>
<ul>
<li>先看效果：</li>
</ul>
<p><img src="/images/searchDisplayController_1.png" alt="searchDisplayController_1"> <img src="/images/searchDisplayController_2.png" alt="searchDisplayController_2"></p>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[static关键字和const关键字]]></title>
    <link href="http://yoursite.com/2014/07/24/staticguan-jian-zi-he-constguan-jian-zi/"/>
    <id>http://yoursite.com/2014/07/24/staticguan-jian-zi-he-constguan-jian-zi/</id>
    <published>2014-07-24T02:04:52.000Z</published>
    <updated>2015-08-20T19:38:45.000Z</updated>
    <content type="html"><![CDATA[<p>这两个关键字平时可能用得比较多，但有时还是会记不住他们的用法，特此记录一下</p>
<h2 id="static">static</h2><p>直接说它的作用可能会更直观，使用static关键字修饰的变量：</p>
<ul>
<li>称为静态变量，当你是在程序开始时就创建了它，那么它整个生命周期是从程序开始到结束，也就说在程序结束之前，会一直占着内存，系统不会释放。</li>
<li>只会初始化一次</li>
<li>适用于只需初始化一次的变量，例如记录页面的访问次数、操作次数等。</li>
</ul>
<h2 id="const">const</h2><ul>
<li>常量，初始化了就不能修改的</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>这两个关键字平时可能用得比较多，但有时还是会记不住他们的用法，特此记录一下</p>
<h2 id="static">static</h2><p>直接说它的作用可能会更直观，使用static关键字修饰的变量：</p>
<ul>
<li>称为静态变量，当你是在程序开始时就创建了]]>
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Grand Central Dispatch(GCD)学习]]></title>
    <link href="http://yoursite.com/2014/07/21/grand-central-dispath-gcd-xue-xi/"/>
    <id>http://yoursite.com/2014/07/21/grand-central-dispath-gcd-xue-xi/</id>
    <published>2014-07-21T06:18:09.000Z</published>
    <updated>2015-08-20T19:38:15.000Z</updated>
    <content type="html"><![CDATA[<p>学习自：</p>
<p><a href="https://github.com/nixzhu/dev-blog/blob/master/2014-04-19-grand-central-dispatch-in-depth-part-1.md" target="_blank" rel="external">nixzhu 翻译的关于GCD的文章1</a></p>
<p><a href="https://github.com/nixzhu/dev-blog/blob/master/2014-05-14-grand-central-dispatch-in-depth-part-2.md" target="_blank" rel="external">nixzhu 翻译的关于GCD的文章2</a></p>
<p>Grand Central Dispatch 简称GCD，苹果在Mac OS X 10.6 ，iOS 4平台首次发布，后续平台也可用。关于GCD的更多信息，参考<a href="https://developer.apple.com/library/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/Reference/reference.html#//apple_ref/doc/uid/TP40008079-CH1-SW1" target="_blank" rel="external">官方文档</a>。<br><br></p>
<h3 id="特性">特性</h3><ul>
<li>基于队列工作 dispatch queue，严格按照FIFO（first in first out）</li>
<li>平行排队特定任务</li>
<li>利用任何可用核心资源（多核处理器）处理任务</li>
<li>任务：函数（function）、block</li>
</ul>
<p><br><br><a id="more"></a></p>
<h1 id="关于队列">关于队列</h1><h3 id="Serial_-_Serial_dispatch_queues">Serial - Serial dispatch queues</h3><ul>
<li>串行队列，多个serial queue之间同步并发执行，串行fifo队列，适合用于按指定顺序执行的任务，保持线程安全，串行同步安全地访问资源，在应用程序里面，必须明确指定串行队列，可以已根据需要创建足够多的，但不要用serial queue 代替 concurrent queue 处理任务庞大的任务。</li>
<li>一次执行一个任务，按添加顺序执行</li>
<li>每个任务只会在前一个任务完成之后才开始执行</li>
<li>任务执行之间的时间间隔不明朗，完全靠GCD本身调度<br><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_create(&lt;<span class="preprocessor">#const char *label#&gt;, <span class="title">&lt;#dispatch_queue_attr_t attr#&gt;</span>)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><br></p>
<h4 id="Main_dispatch_queue(属于serial_queue)">Main dispatch queue(属于serial queue)</h4><ul>
<li>主线程 queue ，串行队列，在主线程上执行任务，用来更新ui</li>
<li>main thread 有系统自动创建，并会自动关联上你的应用的主线程，若想在应用内使用，可使用以下三种方式：<br><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">调用 dispatch_main</span><br><span class="line"></span><br><span class="line">调用 <span class="built_in">UIApplicationMain</span>(iOS)或者<span class="built_in">NSApplicationMain</span>(OS X)</span><br><span class="line"></span><br><span class="line">使用 <span class="built_in">CFRunLoopRef</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Concurrent_-_Global_dispatch_queue">Concurrent - Global dispatch queue</h3><ul>
<li>并行队列，任务从队列被列出是按FIFO规则的，但是会并行执行</li>
<li>执行完成的顺序是随机的</li>
<li>适合并行处理数量庞大的任务，GCD可以提供四种此类并行队列，只通过各自的优先级不同去区别开来。</li>
<li>注意，因为是全局队列，所以系统同时也在使用这些队列<br><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dispatch_get_global_queue(&lt;<span class="preprocessor">#dispatch_queue_priority_t priority#&gt;, <span class="title">&lt;#unsigned long flags#&gt;</span>)</span></span><br><span class="line"></span><br><span class="line">DISPATCH_QUEUE_PRIORITY_HIGH </span><br><span class="line"></span><br><span class="line">DISPATCH_QUEUE_PRIORITY_DEFAULT </span><br><span class="line"></span><br><span class="line">DISPATCH_QUEUE_PRIORITY_LOW </span><br><span class="line"></span><br><span class="line">DISPATCH_QUEUE_PRIORITY_BACKGROUND</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Custom_Queue_自定义队列">Custom Queue 自定义队列</h3><ul>
<li>根据需要自创建队列，串行的或者并发的</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">dispath_creat_queue(<span class="string">"com.thongbin.custom.queue"</span>,dispath_queue_sttr_t att)</span><br></pre></td></tr></table></figure>
<h1 id="使用">使用</h1><h3 id="dispatch_once">dispatch_once</h3><ul>
<li>dispatch_once执行一个区块对象，在整个应用的生命周期只执行一次，非常适合用于已单列模式创建全局的对象。<br><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Executes a block object once and only once <span class="keyword">for</span> the lifetime of an application.<span class="comment">//官方解释</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">void</span> <span class="built_in">dispatch_once</span>(</span><br><span class="line">   <span class="built_in">dispatch_once_t</span> *predicate,</span><br><span class="line">   dispatch_block_t block);</span><br><span class="line">   </span><br><span class="line"><span class="comment">//   example</span></span><br><span class="line">	+(instancetype)shareDefaultManager</span><br><span class="line">	&#123;</span><br><span class="line">    <span class="keyword">static</span> TBReachabilityManager *_tbDefaultManager = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> once_t;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;once_t, ^()&#123;</span><br><span class="line">         _tbDefaultManager = [[<span class="keyword">self</span> alloc]init];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> _tbDefaultManager;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="dispatch_async">dispatch_async</h3><ul>
<li>提交一个block到一个异步执行的队列，执行完成后马上返回<br><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Submits a block <span class="keyword">for</span> asynchronous execution on a dispatch queue and returns immediately.</span><br><span class="line"></span><br><span class="line">   <span class="keyword">void</span> <span class="built_in">dispatch_async</span>(</span><br><span class="line">   <span class="built_in">dispatch_queue_t</span> queue,</span><br><span class="line">   dispatch_block_t block);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="queue">queue</h5><ul>
<li>block提交得目标队列，在block执行完成之前，系统会保留这个queue，值不能为Null<br><br></li>
</ul>
<h5 id="block">block</h5><ul>
<li>队列执行的目标block，方法会自动执行Block_copy和Block_release，值不能为Null</li>
</ul>
<p>提交bolck到dispatch_queue最基本的方法，队列决定block执行的方式，串行或者并行，当然了，是异步的。</p>
<h4 id="常用的方法">常用的方法</h4><p>我们在处理一些耗时操作时，比如网络读取数据、预服务器交互、数据库读写、io等，有时执行时间过长会导致主界面有卡顿的甚至卡死的情况出现，当然这种情况可以使用NSThread、NSOperation解决，但使用dispatch_async更简单：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="comment">// 耗时的操作，读取数据、数据处理等操作</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="comment">// 更新界面，dispatch_get_main_queue()是切换回主线程队列的方法</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="dispatch_group_async">dispatch_group_async</h3><ul>
<li>以组的方式关联一组block，等block都执行完成，就发起完成的通知，<code>group里面的block是并行执行的</code>。<br><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Submits a block to a dispatch queue and associates the block with the specified dispatch group.</span><br><span class="line"></span><br><span class="line">   <span class="keyword">void</span> dispatch_group_async(</span><br><span class="line">   dispatch_group_t group,</span><br><span class="line">   <span class="built_in">dispatch_queue_t</span> queue,</span><br><span class="line">   dispatch_block_t block);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="使用例子">使用例子</h4><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_get_global_queue<span class="list">(<span class="keyword">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_t group = dispatch_group_create<span class="list">()</span><span class="comment">;</span></span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^&#123;</span><br><span class="line">    [NSThread sleepForTimeInterval:<span class="number">1</span>]<span class="comment">;</span></span><br><span class="line">    NSLog<span class="list">(@<span class="string">"group1"</span>)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^&#123;</span><br><span class="line">    [NSThread sleepForTimeInterval:<span class="number">2</span>]<span class="comment">;</span></span><br><span class="line">    NSLog<span class="list">(@<span class="string">"group2"</span>)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^&#123;</span><br><span class="line">    [NSThread sleepForTimeInterval:<span class="number">3</span>]<span class="comment">;</span></span><br><span class="line">    NSLog<span class="list">(@<span class="string">"group3"</span>)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_notify<span class="list">(<span class="keyword">group</span>, dispatch_get_main_queue<span class="list">()</span>, ^&#123;</span><br><span class="line">    NSLog<span class="list">(@<span class="string">"updateUi"</span>)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">dispatch_release<span class="list">(<span class="keyword">group</span>)</span><span class="comment">;//释放group</span></span><br></pre></td></tr></table></figure>
<p>这里面最后还调用了dispatch_group_notify，因为前面提交的block都被关联到同一个group里面，当group里面的block都执行完成后，就需要调用dispatch_group_notify做收尾。<br><br></p>
<h3 id="dispatch_apply">dispatch_apply</h3><ul>
<li>多次执行传入的block</li>
<li>相当于并发执行任务的for<br><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Submits a block to a dispatch queue <span class="keyword">for</span> multiple invocations.</span><br><span class="line"></span><br><span class="line">   <span class="keyword">void</span> dispatch_apply(</span><br><span class="line">   size_t iterations,</span><br><span class="line">   <span class="built_in">dispatch_queue_t</span> queue,</span><br><span class="line">   <span class="keyword">void</span> (^block)(</span><br><span class="line">   size_t));</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_apply(<span class="number">10</span>, global, ^(size_t index) &#123;</span><br><span class="line">    <span class="comment">// 执行10次</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>学习自：</p>
<p><a href="https://github.com/nixzhu/dev-blog/blob/master/2014-04-19-grand-central-dispatch-in-depth-part-1.md">nixzhu 翻译的关于GCD的文章1</a></p>
<p><a href="https://github.com/nixzhu/dev-blog/blob/master/2014-05-14-grand-central-dispatch-in-depth-part-2.md">nixzhu 翻译的关于GCD的文章2</a></p>
<p>Grand Central Dispatch 简称GCD，苹果在Mac OS X 10.6 ，iOS 4平台首次发布，后续平台也可用。关于GCD的更多信息，参考<a href="https://developer.apple.com/library/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/Reference/reference.html#//apple_ref/doc/uid/TP40008079-CH1-SW1">官方文档</a>。<br><br ></p>
<h3 id="特性">特性</h3><ul>
<li>基于队列工作 dispatch queue，严格按照FIFO（first in first out）</li>
<li>平行排队特定任务</li>
<li>利用任何可用核心资源（多核处理器）处理任务</li>
<li>任务：函数（function）、block</li>
</ul>
<p><br ><br>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[初识iOS]]></title>
    <link href="http://yoursite.com/2014/07/18/chu-shi-ios/"/>
    <id>http://yoursite.com/2014/07/18/chu-shi-ios/</id>
    <published>2014-07-18T06:31:59.000Z</published>
    <updated>2015-08-20T19:37:42.000Z</updated>
    <content type="html"><![CDATA[<h4 id="简介：">简介：</h4><p>iOS（原名：iPhone OS）是由苹果公司为移动设备所开发的操作系统，支持的设备包括iPhone、iPod touch、iPad、Apple TV。与Android及Windows Phone不同，iOS不支持非苹果硬件的设备。系统操作（iOS 7）占用约700-900MB左右的储存空间(其中iPhone、iPod touch占约700MB，iPad占约900MB）。目前，iOS的最新版本为8.0 beta。<br><br></p>
<h4 id="系统架构">系统架构</h4><ul>
<li>框架：iOS使用基于与苹果麦金塔计算器不同的ARM架构的64位或32位中央处理器，使用由PowerVR视频卡渲染的OpenGL ES 3.0以Darwin作为基础[8][9]。</li>
<li>系统架构层次：核心操作系统层（the Core OS layer），核心服务层（the Core Services layer），媒体层（the Media layer），触控应用层（the Cocoa Touch layer）<br><br></li>
</ul>
<p>其实以上的资料都可以在网上找到的，就不摘录了，直接点，想进入iOS开发的世界，可以<a id="more"></a>先攻陷以下几本书：</p>
<ul>
<li><p><a href="http://product.dangdang.com/22881807.html#ddclick?act=click&amp;pos=22881807_0_1_q&amp;cat=&amp;key=objective-c&amp;qinfo=95_1_60&amp;pinfo=&amp;minfo=&amp;ninfo=&amp;custid=&amp;permid=20140512153454357427378240331150676&amp;ref=http%3A%2F%2Fproduct.dangdang.com%2F23312312.html&amp;rcount=&amp;type=&amp;t=1405669671000&amp;ver=A" target="_blank" rel="external">《Objective-C 程序设计 第四版》</a></p>
</li>
<li><p><a href="http://product.dangdang.com/23312312.html#ddclick?act=click&amp;pos=23312312_1_1_q&amp;cat=&amp;key=ios&amp;qinfo=821_1_60&amp;pinfo=&amp;minfo=&amp;ninfo=&amp;custid=&amp;permid=20140512153454357427378240331150676&amp;ref=http%3A%2F%2Fv.dangdang.com%2F&amp;rcount=&amp;type=&amp;t=1405669571000&amp;ver=A" target="_blank" rel="external">《精通iOS开发 第5版》</a><br><br></p>
<h3 id="Apple_在最近的一次WWDC上面发布了最新的Swift语言，具体可以在Cocoachina_Swift这里了解并学习。">Apple 在最近的一次WWDC上面发布了最新的Swift语言，具体可以在<a href="http://www.cocoachina.com/special/swift/" target="_blank" rel="external"><code>Cocoachina Swift</code></a>这里了解并学习。</h3></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="简介：">简介：</h4><p>iOS（原名：iPhone OS）是由苹果公司为移动设备所开发的操作系统，支持的设备包括iPhone、iPod touch、iPad、Apple TV。与Android及Windows Phone不同，iOS不支持非苹果硬件的设备。系统操作（iOS 7）占用约700-900MB左右的储存空间(其中iPhone、iPod touch占约700MB，iPad占约900MB）。目前，iOS的最新版本为8.0 beta。<br><br ></p>
<h4 id="系统架构">系统架构</h4><ul>
<li>框架：iOS使用基于与苹果麦金塔计算器不同的ARM架构的64位或32位中央处理器，使用由PowerVR视频卡渲染的OpenGL ES 3.0以Darwin作为基础[8][9]。</li>
<li>系统架构层次：核心操作系统层（the Core OS layer），核心服务层（the Core Services layer），媒体层（the Media layer），触控应用层（the Cocoa Touch layer）<br><br ></li>
</ul>
<p>其实以上的资料都可以在网上找到的，就不摘录了，直接点，想进入iOS开发的世界，可以]]>
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[基于Octopress 同时在 Github&amp;Gitcafe 上构建blog ]]></title>
    <link href="http://yoursite.com/2014/07/17/ji-yu-octopress-tong-shi-zai-github-and-gitcafe-shang-gou-jian-blog/"/>
    <id>http://yoursite.com/2014/07/17/ji-yu-octopress-tong-shi-zai-github-and-gitcafe-shang-gou-jian-blog/</id>
    <published>2014-07-17T09:17:39.000Z</published>
    <updated>2014-07-18T08:37:33.000Z</updated>
    <content type="html"><![CDATA[<a id="more"></a>]]></content>
    <summary type="html">
    <![CDATA[<a id="more"></a>]]>
    </summary>
    
      <category term="summary" scheme="http://yoursite.com/categories/summary/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[开博文]]></title>
    <link href="http://yoursite.com/2014/07/17/zhong-wen-ban/"/>
    <id>http://yoursite.com/2014/07/17/zhong-wen-ban/</id>
    <published>2014-07-17T03:45:14.000Z</published>
    <updated>2014-07-18T08:37:04.000Z</updated>
    <content type="html"><![CDATA[<p>一直感觉应该写点东西来记录自己学过的知识，却一直缺乏行动。最近手头上的项目因为莫名的原因停滞了，于是抽起了筋，研究了下<a href="http://octopress.org/" target="_blank" rel="external"><code>Otcopress</code></a>搭建了我的第一个blog。<a id="more"></a>本来只是打算放在<a href="https://pages.github.com/" target="_blank" rel="external"><code>github pages</code></a>上的，但我忽略了大天朝这个大环境（骑骑）→_→好吧，这个不多说。现时比较完美的解决方案就是放在<a href="https://gitcafe.com" target="_blank" rel="external"><code>GitCafe</code></a>上，这也是看了<a href="http://blog.devtang.com/blog/2014/06/02/use-gitcafe-to-host-blog/" target="_blank" rel="external"><code>唐大的一篇文章</code></a>，做出的选择，顺便说句，唐大的blog上真的很多干货：）。<br><br><br>至于为什么抽起了筋，大概是因为最近遇到很多事，烦人的7月，各种令你无奈、无助感觉，也是为了积累、总结一下自己这三年的工作学习经历，不然到最后，会发现自己没有什么拿得出手的。<br><br><br>其实觉得更重要的一点是，觉得我可以有个地方去分享自己学习的过程和心得，最好是能收到各方大大的批评和斧正。在程序猿的世界，<code>分享是获得成长的最好方式</code>。<br><br><br>废话不多说了~作为一名合格的程序猿，不应该那么感性，开个玩笑，以这篇开博文，开始我的分享、记录之旅。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>一直感觉应该写点东西来记录自己学过的知识，却一直缺乏行动。最近手头上的项目因为莫名的原因停滞了，于是抽起了筋，研究了下<a href="http://octopress.org/"><code>Otcopress</code></a>搭建了我的第一个blog。]]>
    
    </summary>
    
      <category term="summary" scheme="http://yoursite.com/categories/summary/"/>
    
  </entry>
  
</feed>
